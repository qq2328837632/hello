---
title: c++ 基础
date: 2023-04-08 13:49:29
tags:
---

# 处理类型

## 类型别名

有两种方法可用于定义类型别名。传统的方法是使用关键字typedef:

```
typedef double wages;//wages是 double的同义词

typedef wages base,*p;//base是double的同义词,p是double*的同义词
```

新标准规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名:

```
using SI = Sales_item;/ /SI是sales_item的同义词
```

这种方法用关键字using 作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。

例如以下声明中的内容：

```
typedef long double DBL;

我们引入了一个新的类型名称DBL，它是long double的别名，并且具有：

typedef：存储类说明符

long double：类型说明符

DBL：声明符
```



### 指针、常量和类型别名

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。

例如下面的声明语句用到了类型pstring,它实际上是类型char*的别名:

```
typedef char *pstring;
const pstring cstr = 0;// cstr是指向char的常量指针
const pstring *ps;// ps是一个指针，它的对象是指向char的常量指针
```

上述两条声明语句的基本数据类型都是const pstring，和过去一样，const是对给定类型的修饰。pstring 实际上是指向char的指针，因此，const pstring 就是指向char的常量指针，而非指向常量字符的指针。

遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义:

```
const char *cstr =0;
//是对const pstring cstr的错误理解

```

再强调一遍:这种理解是错误的。声明语句中用到pstring时，其基本数据类型是指针。可是用 char重写了声明语句后，数据类型就变成了char，* 成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针,改写后的形式则声明了一个指向const char的指针。主要是看  * 具体跟谁。这里的区别在于，typedef出来的类型是看做一个单独的类型，而char* 这种直接的写法中，char* 才是单独的类型，*需要看做是和p结合在一起，含义不同。

## 类型说明符

编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值:

```
//由val1和val2相加的结果可以推断出item的类型
auto item = val1 + val2;// item初始化为vall和val2相加的结果
```

此处编译器将根据vall和val2相加的结果来推断item的类型。如果val1和val2是类sales item的对象，则item的类型就是Sales_item;如果这两个变量的类型是double，则item的类型就是double，以此类推。

使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样:

```
auto i = 0, *p=&i;//正确:i是整数、p是整型指针,auto代表int型
auto sz = 0,pi = 3.14;//错误:sz和pi的类型不一致
```

还可以将引用的类型设为auto，此时原来的初始化规则仍然适用:

```
auto  &g=ci;//g是一个整型常量引用，绑定到ci
auto &h=42;//错误:不能为非常量引用绑定字面值
const auto &j=42; //正确:可以为常量引用绑定字面值
```

要在一条语句中定义多个变量，切记，符号&和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型:

```
auto k=ci, &l= i;//k是整数，1是整型引用
auto &m= ci, *p= &ci;// m是对整型常量(const int)的引用，p是指向整型常量(const int)的指针
//错误:i的类型是int而&ci的类型是const int
auto &n= i, *p2= &ci;//使用引用作为初始类型，初始值中的顶层const属性仍然保存,底层 const 的限制却不能被忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转化为常量，反之不行。
```



## decltype类型指示符

有时会遇到这种情况:希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符dec1type，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值:

```
decltype(f()) sum = x; // sum的类型就是函数f的返回类型
```

编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum 的类型。换句话说，编译器为sum 指定的类型是什么呢?就是假如f被调用的话将会返回的那个类型。
decltype处理顶层const和引用的方式与auto有些许不同。如果 decltype使用的表达式是一个变量,则decltype返回该变量的类型(包括顶层const和引用在内):

```
const int ci= 0,&cj=ci;
decltype(ci) x= 0;//x的类型是const int
decltype(cj) y= x;//y的类型是const int&， y绑定到变量x
decltype(cj） z;//错误:z是一个引用，必须初始化
```

因为cj是一个引用，decltype(cj)的结果就是引用类型，因此作为引用的z必须被初始化。

需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外,作为返回值类型。

### decltype 和引用

如果 decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如4.1.1节（第120页）将要介绍的，有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时,意味着该表达式的结果对象能作为一条赋值语句的左值:

```
// decltype的结果可以是引用类型
int i = 42,*p= &i, &r=i;
decltype(r + 0) b;//正确:加法的结果是int，因此b是一个(未初始化的)int
decltype(*p) c;//错误:c是int&，必须初始化
```

因为r是一个引用，因此 decltype (r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。

另一方面，如果表达式的内容是解引用操作，则 decltype 将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype(*p)的结果类型就是int&，而非int。

如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型，切记:decltype ((variable))（注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。

> 赋值是会产生引用的一类典型表达式，**引用的类型就是左值的类型**。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&。根据这一特点，请指出下面的代码中每一个变量的类型和值。
>
> ```cpp
> int a = 3, b = 4;
> decltype(a) c = a;
> decltype(a = b) d = a;
> a int 3；
> b int 4；
> c int 3；
> d int & 3。
> ```

# 自定义数据结构

## 编写自己的头文件

为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。例如，库类型string在名为string的头文件中定义。又如,我们应该把Sales_data类定义在名为Sales_data.h的头文件中。

注意：头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。

### 预处理器概述

C++程序还会用到的一项预处理功能是头文件保护符（header guard)，头文件保护符依赖于预处理变量。预处理变量有两种状态:已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义:#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。
使用这些功能就能有效地防止重复包含的发生:

```
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
#endif
```

# 字符串、向量和数组

## 命名空间的using声明

头文件不应包含using声明

位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会铂贝到所有引用它的文件中去，如果头文件里有某个using 声明,那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字,反而可能产生始料未及的名字冲突。

### 使用getline读取一整行

有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的>>运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去(注意不存换行符)。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。

和输入运算符一样，getline也会返回它的流参数。因此既然输入运算符能作为判断的条件，我们也能用getline的结果作为条件。例如，可以通过改写之前的程序让它一次输出一整行，而不再是每行输出一个词了:

```
while (getline(cin,line))
	cout<< line <<endl;
```

注意：触发getline函数返回的那个换行符实际上被丢弃掉了,得到的string对象中并不包含该换行符。

### string:size_type类型

对于size函数来说，返回一个int或者返回一个 unsigned 似乎都是合情合理的。但其实size函数返回的是一个string: :size type类型的值，下面就对这种新的类型稍作解释。

尽管我们不太清楚string::size_type类型的细节，但有一点是肯定的:它是个**无符号类型**的值,而且能足够存放下任何string对象的大小所有用于存放string类的size函数返回值的变量，都应该是 string::size_type类型的。

在c++11标准中，允许编译器通过auto或者decltype来推断变量的类型:
auto len = line.size();// len的类型是string: :size_type

由于size函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假设n是一个具有负值的int,则表达式s.size ()<n的判断结果几乎肯定是true。这是因为负值n会自动地转换成一个比较大的无符号值。

注意：如果一条表达式中已经有了size()函数就不要再使用int了,这样可以避免混用int和unsigned可能带来的问题。

因为某些历史原因，也为了与C兼容,所以C++语言中的字符串字面值（如“hello”）并不是标准库类型string 的对象。切记，字符串字面值与string是不同的类型。

#### 建议:使用C++版本的C标准库头文件

C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h,C+则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名 name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。

因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的,在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。

一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。

------

新的例子不再是统计标点符号的个数了，假设我们想要把字符串改写为大写字母的形式。为了做到这一点可以使用标准库函数 toupper，该函数接收一个字符，然后输出其对应的大写形式。这样，为了把整个string对象转换成大写，只要对其中的每个字符调用toupper函数并将结果再赋给原字符就可以了:

```
string s("Hello World!!!");
//转换成大写形式。
for (auto &c :s)//对于s中的每个字符（注意:c是引用)
	c= toupper(c);//c是一个引用，因此赋值语句将改变s中字符的值
cout<<s<<endl;
```

每次迭代时，变量c引用string对象s的下一个字符，赋值给c也就是在改变s中对应字符的值。因此当执行下面的语句时，

```
c= toupper(c);//c是一个引用，因此赋值语句将改变s中字符的值
```

实际上改变了c绑定的字符的值。整个循环结束后, str 中的所有字符都变成了大写形式。

```
另一个例子是把s的第一个词改成大写形式:
//依次处理s中的字符直至我们处理完全部字符或者遇到一个空白
for (decltype(s.size()） index = 0;
index != s.size () && !isspace(s[index]); ++index)
	s [index] = toupper (s[index]);//将当前字符改成大写形式
```

使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0而小于字符串的 size()的值。一种简便易行的方法是，总是设下标的类型为string::size_type，因为此类型是**无符号数，可以确保下标不会小于0**。此时，代码只需保证下标小于size()的值就可以了。

## 标准库类型vector

vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。除此之外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector.

```
vector<int> V1 (10);//v1有10个元素，每个的值都是0
vector<int> V2{10};//v2有1个元素，该元素的值是10
vector<int> V3(10,1); // v3有10个元素，每个的值都是1
vector<int> v4{10，1}; // v4有2个元素，值分别是10和1
```

另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。例如，要想列表初始化一个含有string对象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要列表初始化 vector对象的元素还是用给定的容量值来构造vector对象:

```
vector<string> v5{ "hi"};//列表初始化:v5有一个元素
vector<string> v6("hi");//错误:不能使用字符串字面值构建vector对象
vector<string> v7 {10};//v7有10个默认初始化的元素
vector<string> v8{10,"hi"};// v8有10个值为"hi"的元素
```

```
提示:只能对确知已存在的元素执行下标操作!
关于下标必须明确的一点是:只能对确知已存在的元素执行下标操作。例如，
vector<int> ivec;//空vector对象
cout << ivec[0];//错误:ivec不包含任何元素
vector<int> ivec2 (10);//含有10个元素的vector对象
cout << ivec2[10];//错误:ivec2元素的合法索引是从0到9
试图用下标的形式去访问一个不存在的元素将引发错误,不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。
不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的缓冲区溢出(buffer overflow)指的就是这类错误，这也是导致PC及其他设备上应用程序出现安全问题的一个重要原因。
```

### 关键概念:泛型编程

原来使用C或Java的程序员在转而使用C++语言之后,会对for循环中使用!=而非<进行判断有点儿奇怪，C++程序员习惯性地使用!=,其原因和他们更愿意使用迭代器而非下标的原因一样:因为这种编程风格在标准库提供的所有容器上都有效。

之前已经说过,只有string和 vector等一些标准库类型有下标运算符,而并非全都如此。与之类似,所有标准库容器的迭代器都定义了==和!=，但是它们中的大多数都没有定义<运算符。因此,只要我们养成使用迭代器和!-的习惯,就不用太在意用的到底是哪种容器类型。

### 迭代器类型

```
vector<int> : :iterator it;	// it能读写vector<int>的元素
string::iterator it2;//it2能读写string对象中的字符
vector<int>: :const_iterator it3;// it3只能读元素，不能写元素
string : :const_iterator it4;// it4只能读字符,不能写字符
```

const_iterator和常量指针（参见2.4.2节，第56页)差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator;如果vector对象或string对象不是常量,那么既能使用iterator也能使用const_iterator。

### 术语:迭代器和迭代器类型

迭代器这个名词有三种不同的含义:可能是迭代器概念本身，也可能是指容器定义的迭代器类型,还可能是指某个迭代器对象。

重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器**当且仅当它支持一套操作**，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。

每个容器类定义了一个名为 iterator 的类型,该类型支持迭代器概念所规定的一套操作。

### 结合解引用和成员访问操作

注意，（*it). empty()中的圆括号必不可少，该表达式的含义是先对it解引用，然后解引用的结果再执行点运算符。如果不加圆括号，点运算符将由it来执行，而非it解引用的结果:

```
(*it).empty()//解引用it，然后调用结果对象的empty成员
*it.empty ()//错误:试图访问it的名为empty的成员，但it是个迭代器,
			//没有empty成员
```

为了简化上述表达式，C++语言定义了箭头运算符(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it->mem和(*it).mem表达的意思相同。

```
//依次输出text的每一行直至遇到第一个空白行为止
for (auto it = text.cbegin();
	it != text.cend() & & !it->empty;++it)
	cout<<*it<<endl;
```

我们首先初始化it令其指向text的第一个元素，循环重复执行直至处理完了text的所有元素或者发现某个元素为空。每次迭代时只要发现还有元素并且尚未遇到空元素，就输出当前正在处理的元素。值得注意的是，因为循环从头到尾只是读取text的元素而未向其中写值，所以使用了**cbegin和 cend**来控制整个迭代过程。

如果对象只需读操作而无须写操作的话最好使用常量类型(比如const_iterator)。为了便于专门得到const iterator类型的返回值,C++11新标准引入了两个新函数,分别是cbegin和 cend:

**注意**：**谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。**（因为每次容量不够时都需要重新创建一个容器，此时迭代器就变了）

# 数组

## 定义和初始化内置数组

```
unsigned cnt =42;//不是常量表达式
constexpr unsigned sz = 42;//常量表达式
int arr[10];//含有10个整数的数组
int *parr[sz];//含有42个整型指针的数组
string bad [cnt];//错误:cnt不是常量表达式
string strs[get_size()];//当get_size是constexpr时正确;否则错误
默认情况下，数组的元素被默认初始化
```

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和 vector一样，数组的元素应为对象，因此不存在引用的数组。

### 字符数组的特殊性

字符数组有一种额外的初始化形式，我们可以用字符串字面值（参见2.1.3节，第36页）对此类数组初始化。当使用这种方式时，一定要注意**字符串字面值的结尾处还有一个空字符**，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去:

```
char al[]=['C', '+','+'};//列表初始化,没有空字符
char a2[]={'C' + '+'，'+' + '\0'};//列表初始化，含有显式的空字符
char a3[]="C++";//自动添加表示字符串结束的空字符
const char a4[6]="Daniel";//错误:没有空间可存放空字符!
```

al的维度是3,a2和a3的维度都是4,a4的定义是错误的。尽管字符串字面值"Daniel看起来只有6个字符，但是数组的大小必须至少是7，其中6个位置存放字面值的内容，另外1个存放结尾处的空字符。

### 不允许拷贝和赋值

不能将数组的内容铂贝给其他数组作为其初始值，也不能用数组为其他数组赋值:

```
int a[]= {0，1，2};//含有3个整数的数组
int a2[]= a;//错误:不允许使用一个数组初始化另一个数组
a2= a;//错误:不能把一个数组直接赋值给另一个数组
```

一些编译器支持数组的赋值，这就是所谓的编译器扩展(compiler extension)。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。

### 理解复杂的数组声明

```
int *ptrs [10];// ptrs是含有10个整型指针的数组
int &refs[10]=/* ?*/;//错误:不存在引用的数组
int (*Parray)[10] =&arr;// Parray指向一个含有10个整数的数组
int (&arrRef)[10]= arr;// arrRef引用一个含有10个整数的数组
```

默认情况下，类型修饰符从右向左依次绑定。对于ptrs来说，从右向左理解其含义比较简单:首先知道我们定义的是一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。

但是对于Parray来说，从右向左理解就不太合理了。因为数组的维度是紧跟着被声明的名字的，所以就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地理解Parray的含义:首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针,最后观察左边，知道数组中的元素是int。这样最终的含义就明白无误了，Parray是一个指针，它指向一个int 数组，数组中包含10个元素。同理，(&arrRef)表示 arrRef是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型是int。

```
int * (&arry)[10] = ptrs;// arry是数组的引用，该数组含有10个指针
```

按照由内向外的顺序阅读上述语句,首先知道arry是一个引用,然后观察右边知道,arry引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用。

## 访问数组元素

在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。

```
// 以10分为一个分数段统计成绩的数量:0~9,10~19,....90~99,100
unsigned scores[11] = {}; //11个分数段，全部初始化为0
unsigned grade;
while (cin >> grade){
	if (grade <=100)
		++scores [grade/10]; //将当前分数段的计数值加1
}
```

与vector和string一样，当需要遍历数组的所有元素时，最好的办法也是使用范围for语句。例如，下面的程序输出所有的scores:

```
for (auto i: scores)//对于scores中的每个计数值
	cout << i<<"";//输出当前的计数值
cout<<endl;
```

因为维度是数组类型的一部分，所以系统知道数组 scores中有多少个元素，使用范围for语句可以减轻人为控制遍历过程的负担。

## 指针和数组

在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组:

```
int ia[] ={0,1,2,3,4,5,6,7,8,9};// ia是一个含有10个整数的数组
auto ia2(ia);// ia2是一个整型指针，指向ia的第一个元素
ia2 =42;//错误: ia2是一个指针，不能用int值给指针赋值
```

尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式:

```
auto ia2(&ia[0]);//显然ia2的类型是int*
```

必须指出的是，当使用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组:

```
// ia3是一个含有10个整数的数组
decltype(ia) ia3 ={0,1,2,3,4,5,6,7,8,91;
ia3 = p; //错误:不能用整型指针给数组赋值
ia3[4] =i;//正确:把i的值赋给ia3的一个元素
```

内置的下标运算符可以处理负值，当然，结果地址必须指向原来的指针所指同一数组中的元素(或是同一数组尾元素的下一位置)。

内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。

------

比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符;

```
string sl = "A string example";
string s2 ="Adifferent string" ;
if (s1 < s2） // false: s2小于s1
```

如果把这些运算符用在两个C风格字符串上，实际比较的将是指针而非字符串本身:

```
const char cal[]="A string example";
const char ca2[]="A different string";
if (cal < ca2)//未定义的:试图比较两个无关地址
```

**注意：对大多数应用来说,使用标准库string要比使用C风格字符串更安全、更高效。**

## 与旧代码的接口

很多C++程序在标准库出现之前就已经写成了，它们肯定没用到string和 vector类型。而且，有一些C++程序实际上是与C语言或其他语言的接口程序，当然也无法使用C++标准库。因此,现代的C++程序不得不与那些充满了数组和/或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。

更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代:

- 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。
- 在 string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象(不能两个运算对象都是);在 string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

上述性质反过来就不成立了:如果程序的某处需要一个C风格字符串，无法直接用string对象来代替它。例如，不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数:

```
char *str = s;//错误:不能用string对象初始化char*
const char *str = s.c_str();//正确
```

顾名思义，c_ str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以**空字符结束的字符数组**，而这个数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char，从而确保我们不会改变字符数组的内容。

### 使用数组初始化 vector对象

介绍过不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了:

```
int int arr[] ={0,1,2,3,4,5);//ivec有6个元素，分别是int_arr中对应元素的副本vector<int> ivec(begin(int_arr) ,end(int_arr));
```

## 建议:尽量使用标准库类型而非数组

使用指针和数组很容易出错。一部分原因是概念上的问题:指针常用于底层操作，因此容易引发一些与烦琐细节有关的错误。其他问题则源于语法错误,特别是声明指针时的语法错误。

现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针;应该尽量使用string,避免使用C风格的基于数组的字符串。

## 小结

string和 vector是两种最重要的标准库类型。string对象是一个可变长的字符序列，vector对象是一组同类型对象的容器。

迭代器允许对容器中的对象进行间接访问，对于string对象和vector对象来说，可以通过迭代器访问元素或者在元素间移动。

数组和指向数组元素的指针在一个较低的层次上实现了与标准库类型 string和vector类似的功能。一般来说，应该优先选用标准库提供的类型,之后再考虑C++语言内置的低层的替代品数组或指针。

**缓冲区溢出**（buffer overflow)一种严重的程序故障,主要的原因是试图通过一个越界的索引访问容器内容,容器类型包括string、 vector和数组等。

**C风格字符串**（C-style string)以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错。

# 表达式

归纳:当一个对象被用作右值的时候，用的是对象的值（内容);当对象被用作左值的时候，用的是对象的身份（在内存中的位置)。

使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式(不是变量)得到一个引用类型。举个例子,假定p的类型是 int* ，因为解引用运算符生成左值,所以decltype(*p)的结果是int&。另一方面，因为取地址运算符生成右值，所以decltype (&p)的结果是int**，也就是说，结果是一个指向整型指针的指针。

有4种运算符明确规定了运算对象的求值顺序。第一种是逻辑与（&&）运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。另外三种分别是逻辑或()运算符、条件（?:）运算符和逗号(，)运算符。

求值顺序、优先级、结合律
运算对象的求值顺序与优先级和结合律无关,在一条形如f()+g()*h()+j（)的表达式中:如果f、g、h和j是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。

**建议:处理复合表达式**

以下两条经验准则对书写复合表达式有益:

- 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
- 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。第2条规则有一个重要例外,当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，在表达式*++iter中，递增运算符改变iter的值，iter(已经改变）的值又是解引用运算符的运算对象。此时(或类似的情况下),求值的顺序不会成为问题，因为递增运算(即改变运算对象的子表达式)必须先求值,然后才轮到解引用运算。显然，这是一种很常见的用法、不会造成什么问题。

## 算术运算符

```
bool b= true;
bool b2 =-b;
// b2是true!
```

对大多数运算符来说，布尔类型的运算对象将被提升为 int类型。如上所示，布尔变量b的值为真，参与运算时将被提升成整数值1，对它求负后的结果是-1.将-1再转换回布尔值并将其作为b2的初始值,显然这个初始值不等于0，转换成布尔值后应该为1。所以，b2的值是真!

在除法运算中，如果两个运算对象的符号相同则商为正(如果不为0的话)，否则商为负。C++语言的早期版本允许结果为负值的商向上或向下取整，**C++11**新标准则规定商一律向0取整(即直接切除小数部分)。

**建议:除非必须，否则不用递增递减运算符的后置版本**

有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问,其实原因非常简单:前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值,那么后置版本的操作就是一种浪费。
对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化;但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题,而且更重要的是写出的代码会更符合编程的初衷。

**建议:简洁可以成为一种美德**
形如*pbeg++的表达式一开始可能不太容易理解，但其实这是一种被广泛使用的、有效的写法。当对这种形式熟悉之后,书写
cout<<  *iter++ <endl;
要比书写下面的等价语句更简洁、也更少出错
cout << *iter <<endl;
++iter;
不断研究这样的例子直到对它们的含义一目了然。大多数C+程序追求简洁、摒弃冗长，因此C++程序员应该习惯于这种写法。而且，一旦熟练掌握了这种写法后，程序出错的可能性也会降低。

# sizeof运算符

- sizeof运算符的结果部分地依赖于其作用的类型:
- 对char或者类型为char的表达式执行sizeof运算，结果得1。
- 对引用类型执行sizeof运算得到被引用对象所占空间的大小。对指针执行sizeof运算得到指针本身所占空间的大小。
- 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小,指针不需有效。
- 对数组执行sizeof运算得到整个数组所占空间的大小,等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数:

```
//sizeof(ia)/sizeof(*ia)返回ia的元素数量
constexpr size_t sz =sizeof (ia)/sizeof(*ia);
int arr2[sz];//正确:sizeof返回一个常量表达式
```

因为sizeof的返回值是一个常量表达式,所以我们可以用sizeof的结果声明数组的维度。

# 类型转换

**何时发生隐式类型转换**
	在下面这些情况下，编译器会自动地转换运算对象的类型:

- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型;在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
- 函数调用时也会发生类型转换。

```
string s, t= "a value" ;//字符串字面值转换成string类型
while (cin >>S)// while的条件部分把cin转换成布尔值
```

条件(cin>>s）读入cin的内容并将cin作为其求值结果。条件部分本来需要一个布尔类型的值，但是这里实际检查的是istream类型的值。幸好，IO库定义了从istream向布尔值转换的规则，根据这一规则，cin自动地转换成布尔值。所得的布尔值到底是什么由输入流的状态决定，如果最后一次读入成功，转换得到的布尔值是true:相反，如果最后一次读入不成功，转换得到的布尔值是false。

### static_cast

任何具有明确定义的类型转换，只要不包含底层const（见最下注释），都可以使用static_cast.

基本语法如下：

```
1 typename value = static_cast<typename>(expression);
```

例如：

```
1 double x = static_cast<double> (y);//y可以是多种类型
```

实际上，将大型算术类型转换给小型算术类型时很有用(如double转换为int),使用static_cast告诉编译器，我知道会损失精度但是并不在乎，这样编译器就不会发出警告。

更让人高兴的是，static_cast对于编译器无法自动执行的类型转换提供了很好的支持。

static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast 找回存在于 void*指针中的值。

当我们把指针存放在void*  中，并且使用static_cast将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址值相等，因此我们必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。

例如：

```
1 double somevalue = 3.14;
2 void *p = &somevalue;//正确:任何非const对象的地址都能存入void*,但是不能通过p修改somevalue,即不包含底层const
3 double *pd = static_cast<double*>(p);//正确
```

经过测试，*p和 *pd都是指向somevalue的。

### const_cast

const_cast只能改变运算对象的底层const.
语法规则如下：

```
1 type something = const_cast<type>(expression);
1 const char* pc;
2 char *p = const_cast<char*>(pc);//正确:但是通过p写值是未定义的行为
```

要注意的是，这种转换只能更改引用或者指针，也就是说下面这种写法是报错的。

```
1 const int a = 100;
2 int b = const_cast<int>(a);//error: invalid use of const_cast with type 'int', which is not a pointer, reference, nor a pointer-to-data-member type
```

 对于将常量对象转换成非常量对象的行为，我们称其为“去掉const性质”(cast away the const)，一旦失去了某个对象的const性质，编译器将不再阻止我们对该对象进行修改但是一定要注意的是：如果对象本身是一个常量，将常量转换为非常量后，使用转换后的非常量修改值是未定义行为（undefined behavior），虽然编译器不会报错也不会waring，但是不同的编译器对这种行为有不同的判断，因此这是一种非常危险的行为。但如果对象本身不是一个常量，在cast away the const 后，修改其内容是合法的。

```
#include <iostream>
using namespace std;

void f(int* p) {
  cout << *p << endl;
}

int main(void) {
  const int a = 10;
  const int* b = &a;

  // Function f() expects int*, not const int*
  //   f(b);
  //编译器不允许调用f(b)因为f()的参数为int*不是const int*,此时用const_cast可以去掉const后传递进去
  int* c = const_cast<int*>(b);
  f(c);//c是转换类型得到的，可以调用f(int*)

  // Lvalue is const
  //  *b = 20;
//不允许*b = 20，这是const_cast规定的，但是实际上不会报错，这是一种未定义行为，不同的编译器有不同的处理结果
  // Undefined behavior
  //  *c = 30;

  int a1 = 40;
  const int* b1 = &a1;
  int* c1 = const_cast<int*>(b1);//a1 is not a const,so we can use c1 to change the value of al

  // Integer a1, the object referred to by c1, has
  // not been declared const
  *c1 = 50;
//不过如果原对象本身是非const的，通过c1修改a1是完全安全的
  return 0;
}
```

在早期版本的CH+语言中，显式地进行强制类型转换包含两种形式:

type (expr);//函数形式的强制类型转换
(type) expr;//C语言风格的强制类型转换

与命名的强制类型转换相比,旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题,追踪起来也更加困难。

# 语句

```
如果需要为某个 case分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有case标签都在变量的作用域之外。
case true:
	{
		//正确:声明语句位于语句块内部
		string file_name = get_file_name ();
		// ...
	}
	break;
case false:
	if (file_name. empty())//错误:file _name不在作用域之内,{}内一个作用域
```

## continue语句

continue语句（continue statement）终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for、while和 do while循环的内部，或者嵌套在此类循环里的语句或块的内部。和 break语句类似的是，出现在嵌套循环中的continue 语句也仅作用于离它最近的循环。和 break语句不同的是，只有当switch语句嵌套在迭代语句内部时，才能在switch里使用continue。

## goto语句

和switch 语句类似，goto语句也不能将程序的控制权从变量的作用域之外转移到作用域之内:

```
	// ...
	goto end;
	int ix = 10;//错误:goto语句绕过了一个带初始化的变量定义
end:
	//错误:此处的代码需要使用ix，但是goto语句绕过了它的声明
	ix=42;
```

向后跳过一个已经执行的定义是合法的。跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它:	

```
//向后跳过一个带初始化的变量定义是合法的
begin:
	int sz = get_size() ;
	if(sz <=0） {
		goto begin;
      }
```

在上面的代码中，goto语句执行后将销毁sz。因为跳回到 begin的动作跨过了sz的定义语句，所以sz将重新定义并初始化。

## try 语句块和异常处理

异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的部分。

异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言中，异常处理包括:

- throw表达式(throw expression)，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发（raise）了异常。
- try语句块（try block)，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句（catch clause）结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码（exception handler)。
- 一套异常类（exception class)，用于在throw表达式和相关的catch子句之间传递异常的具体信息。

### 函数在寻找处理代码的过程中退出

在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。

寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的 catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。

如果最终还是没能找到任何匹配的 catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。

对于那些没有任何try语句块定义的异常，也按照类似的方式处理:毕竟,没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。

```
int i1,i2;
while( std ::cin >> i1 >>i2){
	try{
		if(i2==0){
			throw std : : runtime_error ( "divisor can 't be 0" );
			//将控制权转移到相关的catch子句
		}
		std: : cout << i1/i2 << std : : endl;
	}catch(std :: runtime_error err)
	{
		std : : cout << err.what()
			<<"\ntry again? enter y or n" c< std : :endl;
			char c;
			std: :cin >> c;
		if( !std ::cin ||c == 'n ' ) break;
	}
}
```

- try 和 catch,将一段可能抛出异常的语句序列括在花括号里构成try语句块。catch子句负责处理代码抛出的异常。
- throw表达式语句,存在于代码块中,将控制权转移到相关的catch子句。

异常安全(exception safe）是一个术语，表示的含义是当抛出异常后,程序能执行正确的行为。
