---
title: 第二天 c++
date: 2023-03-30 16:01:35
tags:
---

# 空指针

指针变量指向内存中编号为0的空间

用途:初始化指针变量

注意:空指针指向的内存（0-255）是不可以访问的，因为这些初始化的内存往往是系统的一些中断，若想赋值，只能定义其它数值，再把地址赋予指针变量，

```
int a = 10;
int b = 20;
int *p=nullptr;
p=&a;
cout <<*p << endl;
```

# const修饰指针

理解一个**指针常量**的地址是固定的不能更改（int * const p;），但是该地址里面的值是可以更改的。

```
int * const p=&a;
*p=100;//正确的
p=&b;//错误的
```

**常量指针**的地址可变（const int *p;），但是值不能变。

```
const int *p=&a;
*p=100;//错误的
p=&b;//正确的，可以改变指向来改变值
```

const即修饰指针,又修饰常量，指针指向和指向的值都不能变(const int * const p;)。

connst是一个c语言的关键字，具有着举足轻重的地位。它限定一个变量不允许被改变，产生静态作用。使用const在一定程度上可以提高程序的安全性和可靠性。

const修饰规律:修饰的是什么，什么不能（通过此变量)改变。

const修饰结构体（如const student *stu）,可以防止误操作修改stu的值。

其实本质上const关键字只是告诉编译器该修饰的变量不可以被修改，并不能改变它修饰的变量在内存中所存放的区域。即const修饰的全局变量还是在全局区，但是修饰局部变量则在局部区。

------

```
system("pause");//按任意键继续
system("cls");//清屏
```

# 内存分区模型

代码区:存放函数体的二进制代码，由操作系统进行管理的·全局区:存放全局变量和静态变量以及常量。

栈区:由编译器自动分配释放,存放函数的参数值,局部变量等。

堆区:由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收。

内存四区意义:

不同区域存放的数据，赋予不同的生命周期,给我们更大的灵活编程。

## 程序运行前

在程序**编译**后，生成了exe可执行程序，**未执行**该程序前分为两个区域

**代码区**:

存放CPU执行的机器指令

代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可代码区是只读的，使其

只读的原因是防止程序意外地修改了它的指令

**全局区**:

全局变量和静态变量存放在此.全局区还包含了常量区,字符串常量和其他常量也存放在此.该区域的数据在程序结

后由操作系统释放.

## 程序运行后

**栈区**：

由编译器自动分配释放,存放函数的参数值,局部变量等。

注意事项:不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。

**堆区：**

由程序员分配释放,若程序员不释放,程序结束时由操作系统回收。在C++中主要利用new在堆区开辟内存。

```
//利用new关键字，可以将数据开辟到堆区,new返回的该数据类型的指针。
//指针本质也是局部变量，放在栈上，指针保存的数据是放在堆区。
int *p=new int(10);//堆区存放10，p是地址
int *arr=new int[10];//创建数组，10个连续的地址
delete[] arr;//释放数组要加[]
delete p;//释放内存
```

不释放动态内存有个专有名词，叫内存泄漏，内存泄漏就是这块数据已经不需要了，但是没有将这块数据清除，

会一直占用内存，这就是内存泄漏。内存数据放硬盘上的操作叫进程的挂起。

# 引用

```
//引用基本语法
//数据类型 &别名=原名
int a = 10;
//创建引用
int &b = a;
cout << "a = " << a << end1;
cout << "b = " << b<< endl;//两个输出一样,即两个指向同一个地址
```

## 引用注意事项

引用必须初始化。

```
int &b;//错误的
```

引用在初始化后，不可以改变。即b已经是a的别名，则不能是c的别名。



## 引用做函数参数

**作用**:函数传参时，可以利用引用的技术让形参修饰实参。

**优点**:可以简化指针修改实参

```
void swap(&a,&b){

}
int main(){
swap(a,b);//引用传递，形参会修饰实参的,在传递时就已经初始化了，即&a=a;
}
```

总结:通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单。

## 引用做函数的返回值

```
//1、不要返回局部变量的引用
int& test01()
{
int a = 10;//局部变量存放在四区中的栈区
return a;//返回的是int&类型

}

//2、函数的调用可以作为左值,即在main函数可以这样写test02()=1000；则ref输出也会变1000
//返回静态变量引用
int& test02()
{
static int a = 20;//此时可以输出正确，因为static
return a;
}

int main() {


int &ref = test01();//接受的也需要int&类型,&ref是a的别名


cout<<"ref="<<ref<<endl;//第一次结果正确，是因为编译器做了保留，局部变量的返回也是如此
Cout<<“ref=“<<ref<<endl;//第二次结果错误，因为a的内存已经释放
}

```

## 引用的本质

引用相当于指针常量，指向的值能改但指向不能改（即指向地址不变）。

```
int& ref=a;//自动转换为int * const ref=&a;
ref=20;//内部发现ref是引用，自动转换为：*ref =20;
```

指针常量是不能拿函数当左值的,所以引用不仅仅是懒人版指针。

引用的地址和原变量是一样的，指针和原变量的地址不一样。所以引用更省空间。

结论:C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了。 

## 常量引用

```
//引用通常修饰形参（val）
void showValue(const int &val){
	//val=1000;//const防止误操作，相当于这个函教是传入了一个常量指针常量。既不能修改值，又不能修改指向，如果没有const，val修改则main函数的a值也会改变,相当于前面地址传递。

	
}
int main(){
	//int& ref = 10;引用本身需要一个合法的内存空间，因此这行错误
	const int& ref - 10;//加入const就可以了，编译器会优化这行代码为int temp = 10; const int& ref = temp;temp是临时变量
	int a=100;
	showValue(a);
}
```

