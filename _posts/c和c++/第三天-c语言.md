---
title: 第三天 c语言
date: 2023-03-16 10:14:44
tags:
---



# 指针

```
#include <stdio.h>
 
int main ()
{
    int var_runoob = 10;
    int *p;              // 定义指针变量
    p = &var_runoob;
 
   printf("var_runoob 变量的地址： %p\n", p);
   return 0;
}
```

1）p是一个指针，存储var的地址

2）p的类型必须与var类型一致，因为整形指针只能存储整形变量的指针

**指针的一些复杂说明：**

-  **int p;** -- 这是一个普通的整型变量
-  **int \*p;** -- 首先从 p 处开始,先与*结合,所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。所以 p 是一个返回整型数据的指针。
-  **int p[3]** -- 首先从 p 处开始,先与[] 结合,说明 p 是一个数组, 然后与 int 结合, 说明数组里的元素是整型的, 所以 p 是一个由整型数据组成的数组。
-  **int \*p[3];** -- 首先从 p 处开始, 先与 [] 结合, 因为其优先级比 * 高,所以 p 是一个数组, 然后再与 * 结合, 说明数组里的元素是指针类型, 然后再与 int 结合, 说明指针所指向的内容的类型是整型的, 所以 p 是一个由返回整型数据的指针所组成的数组。
-  **int (\*p)[3];** -- 首先从 p 处开始, 先与 * 结合,说明 p 是一个指针然后再与 [] 结合(与"()"这步可以忽略,只是为了改变优先级), 说明指针所指向的内容是一个数组, 然后再与int 结合, 说明数组里的元素是整型的。所以 p 是一个指向由整型数据组成的数组的指针。
-  **int \**p;** -- 首先从 p 开始, 先与 * 结合, 说是 p 是一个指针, 然后再与 * 结合, 说明指针所指向的元素是指针, 然后再与 int 结合, 说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针。
-  **int p(int);** -- 从 p 处起,先与 () 结合, 说明 p 是一个函数, 然后进入 () 里分析, 说明该函数有一个整型变量的参数, 然后再与外面的 int 结合, 说明函数的返回值是一个整型数据。
-  **int (\*p)(int);** -- 从 p 处开始, 先与指针结合, 说明 p 是一个指针, 然后与()结合, 说明指针指向的是一个函数, 然后再与()里的 int 结合, 说明函数有一个int 型的参数, 再与最外层的 int 结合, 说明函数的返回类型是整型, 所以 p 是一个指向有一个整型参数且返回类型为整型的函数的指针。
-  **int \*(\*p(int))[3];** -- 可以先跳过, 不看这个类型, 过于复杂从 p 开始,先与 () 结合, 说明 p 是一个函数, 然后进入 () 里面, 与 int 结合, 说明函数有一个整型变量参数, 然后再与外面的 * 结合, 说明函数返回的是一个指针, 然后到最外面一层, 先与[]结合, 说明返回的指针指向的是一个数组, 然后再与 * 结合, 说明数组里的元素是指针, 然后再与 int 结合, 说明指针指向的内容是整型数据。所以 p 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数。

## C 指针的算术运算

假设 **ptr** 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：

```
ptr++
```

在执行完上述的运算之后，**ptr** 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 **ptr** 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。

我们概括一下：

- 指针的每一次递增，它其实会指向下一个元素的存储单元。
- 指针的每一次递减，它都会指向前一个元素的存储单元。
- 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。

##  指针数组

```
int *ptr[MAX];
```

在这里，把 **ptr** 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。

**add:**

const的好处，是引入了常量的概念，让我们不要去修改某一块不该修改的内存，使某一值被保护起来避免出现错误，在编码过程中考虑const是良好的习惯，无论是常量的定义还是类中的const函数。
static我认为最大的用处在于共享。static设置了函数或变量的存储方式：存储在静态存储区域。它使得局部变量和类成员变量的生命周期变长了（因为其存储方式的特殊性）。它使类成员函数更像是一份各个对象共享的代码，使类成员变量也能在各个对象之间共享，它虽然不属于类中的成员，却能被同一类的各个对象为之所用。

在函数前加static，则此函数成为**静态函数（内部函数）**，我们用static修饰函数的主要目的是：**用来表示不能被其它文件访问的一个函数（和用static修饰全局变量的目的一样，都是不允许其它文件访问）。**这样一来便有一个好处：**程序员不用担心自己编写的函数与其他文件的函数同名**。

具有全局作用域，只初始化一次，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即**被 static 关键字修饰过的变量具有文件作用域。**（使得作用域仅限于被定义的文件中 即，从变量定义到本文件结尾处，其他文件不论通过什么方式都不能访问）。

const和static（**怀疑**）修饰的全局变量如果要在多个文件之间共享，则可以在其他文件需要时使用extern关键字,声明外部变量，使用时一定包含所定义变量所在的文件:

```
//file.h
const int a = 10;
static int b = 100;
```

```
//file2
#include “file.h”

extern const int a;
extern int b;//不需加static关键字
```

无论对于const修饰的变量a还是static变量b，这样做的结果是，整个工程的程序链接完成后，所有需要使用该变量的程序共享同一个这个变量的存储区域。

**指针数组**：指针的数组，实际是一个数组，长度由数组本身决定，这个数组的所有元素都是指针类型，存放的都是地址。**int \*a[3]**：为什么这里是指针数组，**[]** 的优先级高于 ***** ，所以这是一个数组，而 ***** 修饰数组，所以是指针数组，数组的元素是整型的指针。

**int \*prt[ 10 ] ; \*prt[ 1 ],\*prt[ 2 ],\*prt[ 3 ]......** 数组中每个元素都指向一个地址。

**数组指针**：数组的指针，实际是一个指针，长度固定(32 位系统下占 4 个字节)，这个指针指向数组，但指向的数组占多少个字节不确定。**int (\*a)[3]**：同样的方式，首先括号的优先级最高，所以 ***a** 是指针，而 **[]** 修饰 ***a** ，所以是数组指针，一个指向 3 个元素的一维数组指针。

```
int  a[5]={ 1,2,3,4,5 };    //定义一个一维数组 a
int  (*prt)[5];      // 步长为 5 的数组指针，即 prt 指向的数组里有 5 个元素  
prt=&a;    // 把数组 a 的地址付给 prt，则 prt 为数组 a 的地址，*prt 表示数组 a 本身
prt[ 0 ];    //表示数组首元素的地址
*prt[ 0 ]；  //表示数组的首元素的值，即为数组 a 的 1
**prt;         //表示数组的首元素的值，即为数组 a 的 1
*prt[ 1 ] ;   //表示指向数组的下一行元素的首元素的值，但是a是一维数组，只有一行，所以指向的地址中的值不确定
```

数组指针加 1，步长为所指向数组的列数，即为下一行的首地址，只在二维及以上维度的数组中有意义，一维数组只有一行，无意义。

## C 指向指针的指针

指针更像是一个找地址开门取物品的操作。其中 ***** 就是这个动作重复的次数，**ptr** 是取东西的门牌号也就是地址值：

-  ***ptr** 是完成一次开门取东西操作最终取出来的东西。
-  ***\*ptr** 是完成两次开门取物.需要注意的是第一次取得的是第二次要开的门的门牌号或者说地址，然后根据门牌号继续开门取物。 所以 ***ptr** 或者 ***\*ptr** 一定是取出来的东西，即为数值。而 **ptr** 一定是门牌号，即为地址值。

## C 传递指针给函数

### 指针和函数的关系

**1、函数指针（指向函数的指针）**

一个函数在编译之后，会占据一部分内存，而它的函数名，就是这段函数的首地址。

可以把一个指针声明成为一个指向函数的指针。

C 语言规定函数名会被转换为指向这个函数的指针，除非这个函数名作为 & 操作符或 sizeof 操作符的操作数(注意：函数名用于 sizeof 的操作数是非法的)。也就是说 f = test; 中 test 被自动转换为 &test，而 f = &test; 中已经显示使用了 &test，所以 test 就不会再发生转换了。因此直接引用函数名等效于在函数名上应用 & 运算符，两种方法都会得到指向该函数的指针。

指向函数的指针必须初始化，或者具有 0 值，才能在函数调用中使用。

与数组一样：

-  （1）禁止对指向函数的指针进行自增运算++
- （2）禁止对函数名赋值，函数名也不能用于进行算术运算。

示例1:

```
int fun1(int,int);
int fun1(int a, int b){ 
    return a+b;
}
int main(){
    int (*pfun1)(int,int); 
    pfun1=fun1;//这里&fun1和fun1的值和类型都一样，用哪个无所谓 
    int a=(*pfun1)(5,7); //通过函数指针调用函数。
}
```

示例2:

```
#include <stdio.h>
#include <stdlib.h>
int Max(int x, int y)  //定义Max函数
{
    int z;
    if (x > y) {
        z = x;
    }else { 
        z = y;
    }
    return z;
}
int main() {//定义一个函数指针
    int(*p)(int, int);
    int a, b, c;//把函数Max赋给指针变量p, 使p指向Max函数
    p = Max;
    printf("please enter a and b:");
    scanf("%d%d", &a, &b);//通过函数指针调用Max函数
    c = (*p)(a, b);
    printf("a = %d\nb = %d\nmax = %d\n", a, b, c);
    system("pause");
    return 0;
}
```

示例3:

```
#include <stdio.h> 
void test( ){
    printf("test called!/n");
} 
int main( ){   
    void (*f) ( );   
    f = test;     
    f ( ); 
    (*f)( );    
    //test++;             // error，标准禁止对指向函数的指针进行自增运算          
    //test = test + 2;    // error，不能对函数名赋值，函数名也不能用于进行算术运算          
    printf("%p/n", test);          
    printf("%p/n", &test);          
    printf("%p/n", *test);  
    return 0;
}
```

运行结果为：

```
test called!
test called!
004013EE004013EE004013EE
```

这里的玄学就是 *test 为什么能和上面两个之前介绍过的输出一样的值。

首先来看函数名 test，是一个符号用来标识一个函数的入口地址，在使用中函数名会被转换为指向这个函数的指针，指针的值就是函数的入口地址，&test 在前面已经说了：显示获取函数的地址。*test 可以认为由于 test 已经被转换成了函数指针, 指向这个函数，所以 *test 就是取这个指针所指向的函数名，而又根据函数名会被转换指向该函数的指针的规则，这个函数也转变成了一个指针，所以 *test 最终也是一个指向函数 test 的指针。也就是说:*(**test --> \*(&test) --> test --> &test*)。

## C 从函数返回指针

C 不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。

因为局部变量是存储在内存的栈区内，当函数调用结束后，局部变量所占的内存地址便被释放了，因此当其函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。

除非将其变量定义为 static 变量，static 变量的值存放在内存中的静态数据区，不会随着函数执行的结束而被清除，故能返回其地址。

## 一些其他的：

sizeof(数组名)返回的是数组的大小

sizeof(ca)=7，注意此处包含一个结束符
sizeof(cb)=18，

sizeof(一维数组指针)返回的是数组单个元素指针的大小，即系统指针的长度，32位系统为4，64位系统位8

64位：sizeof(pca)=8，32位：sizeof(pca)=4

sizeof(*一维数组指针)返回的是数组单个元素对应类型的大小

sizeof(*pca)=1，char的大小

sizeof(二维数组指针)返回的是二维数组行指针的大小，32位系统为行数×4，64位系统位行数×8

sizeof(pcb)等同于sizeof(pcb[0])、sizeof(pcb[1])、sizeof(pcb[2])

64位：sizeof(pcb)=24，3行×8，注意二维数组每一行的结尾没有结束符'\0'，所以是行长度为8

32位：sizeof(pcb)=12，3行×4，

sizeof(*二维数组指针)返回的是系统指针的长度，32位系统为4，64位系统位8

64位：sizeof(pcb)=8，32位：sizeof(pcb)=4

sizeof(**二维数组指针)返回的是数组单个元素指针的大小，即char的大小

sizeof(**pcb)=1

------

**下面总结一下数组的数组名(数组中储存的也是数组)的问题:**

声明了一个数组 **TYPE array[n]**，则数组名称 array 就有了两重含义：

- 第一，它代表整个数组，它的类型是 **TYPE[n]**；
- 第二，它是一个常量指针，该指针的类型是 **TYPE\***，该指针指向的类型是 **TYPE**，也就是数组单元的类型，该指针指向的内存区就是数组第 0 号单元，该指针自己占有单独的内存区，注意它和数组第 0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似 array++ 的表达式是错误的。在不同的表达式中数组名 array 可以扮演不同的角色。在表达式 sizeof(array) 中，数组名 array 代表数组本身，故这时 sizeof 函数测出的是整个数组的大小。

在表达式 *array 中，array 扮演的是指针，因此这个表达式的结果就是数组第 0 号单元的值。**sizeof(\*array)** 测出的是数组单元的大小。

表达式 array+n（其中n=0，1，2，.....）中，array 扮演的是指针，故array+n 的结果是一个指针，它的类型是 **TYPE \***，它指向的类型是 TYPE，它指向数组第 n 号单元。**故sizeof(array+n)测出的是指针类型的大小。在 32 位程序中结果是 4。**

------

这里 **&** 是取地址运算符，***** 是间接运算符。

**&a** 的运算结果是一个指针，指针的类型是 a 的类型加个 *，指针所指向的类型是 a 的类型，指针所指向的地址嘛，那就是 a 的地址。

***p** 的运算结果就五花八门了。总之 *p 的结果是p 所指向的东西，这个东西有这些特点：它的类型是 p 指向的类型，它所占用的地址是 p 所指向的地址。

实例:

```
int a=12; int b; int *p; int **ptr;
p=&a; //&a 的结果是一个指针，类型是int*，指向的类型是
//int，指向的地址是a 的地址。
*p=24; //*p 的结果，在这里它的类型是int，它所占用的地址是
//p 所指向的地址，显然，*p 就是变量a。
ptr=&p; //&p 的结果是个指针，该指针的类型是p 的类型加个*，
//在这里是int **。该指针所指向的类型是p 的类型，这
//里是int*。该指针所指向的地址就是指针p 自己的地址。
*ptr=&b; //*ptr 是个指针，&b 的结果也是个指针，且这两个指针
//的类型和所指向的类型是一样的，所以用&b 来给*ptr 赋
//值就是毫无问题的了。
**ptr=34; //*ptr 的结果是ptr 所指向的东西，在这里是一个指针，
//对这个指针再做一次*运算，结果是一个int 类型的变量。
```

------

实例：

```
char *str[3]={
    "Hello,thisisasample!",
    "Hi,goodmorning.",
    "Helloworld"
};
char s[80]；
strcpy(s,str[0]); //也可写成strcpy(s,*str);
strcpy(s,str[1]); //也可写成strcpy(s,*(str+1));
strcpy(s,str[2]); //也可写成strcpy(s,*(str+2));
```

上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名 str 当作一个指针的话，它指向数组的第 0 号单元，它的类型是 char **，它指向的类型是 char *。

*str 也是一个指针，它的类型是 char *，它所指向的类型是 char，它指向的地址是字符串 "Hello,thisisasample!" 的第一个字符的地址，即 'H' 的地址。**注意:字符串相当于是一个数组, 在内存中以数组的形式储存, 只不过字符串是一个数组常量, 内容不可改变,且只能是右值.如果看成指针的话, 他即是常量指针, 也是指针常量。**

str+1 也是一个指针，它指向数组的第 1 号单元，它的类型是 char**，它指向的类型是 char*。

*(str+1) 也是一个指针，它的类型是 char*，它所指向的类型是 char，它指向 "Hi,goodmorning." 的第一个字符 'H'。

------

例如：

```
int(*ptr)[10];
```

则在 32 位程序中，有：

```
sizeof(int(*)[10])==4
sizeof(int[10])==40
sizeof(ptr)==4
```

实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。

------

在指针的强制类型转换：**ptr1=(TYPE \*)ptr2** 中，如果 sizeof(ptr2的类型)大于 sizeof(ptr1 的类型)，那么在使用指针 ptr1 来访问 ptr2 所指向的存储区时是安全的。如果 sizeof(ptr2 的类型) 小于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。

如果ptr2不是指针类型则

```
char s='a';
int *ptr;
ptr=(int *)&s;
```

