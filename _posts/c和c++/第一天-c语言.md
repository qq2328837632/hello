---
title: 第一天 c语言
date: 2023-03-13 14:53:57
tags:
---

## C 中的变量声明

变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

变量的声明有两种情况：

- 1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。
- 2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。
- 除非有extern关键字，否则都是变量的定义。

```c
extern int i; //声明，不是定义
int i; //声明，也是定义
```

### 实例

尝试下面的实例，其中，变量在头部就已经被声明，但是定义与初始化在主函数内：

## 实例

```
#include <stdio.h>
 
// 函数外定义变量 x 和 y
int x;
int y;
int addtwonum()
{
    // 函数内声明变量 x 和 y 为外部变量
    extern int x;
    extern int y;
    // 给外部变量（全局变量）x 和 y 赋值
    x = 1;
    y = 2;
    return x+y;
}
 
int main()
{
    int result;
    // 调用函数 addtwonum
    result = addtwonum();
    
    printf("result 为: %d",result);
    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
result 为: 3
```

如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。

## addtwonum.c 文件代码：

```
#include <stdio.h>
/*外部变量声明*/
extern int x ;
extern int y ;
int addtwonum()
{
    return x+y;
}
```



## test.c 文件代码：

```
#include <stdio.h>
  
/*定义两个全局变量*/
int x=1;
int y=2;
int addtwonum();
int main(void)
{
    int result;
    result = addtwonum();
    printf("result 为: %d\n",result);
    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
$ gcc addtwonum.c test.c -o main
$ ./main
result 为: 3
```

### c/c++中的lvaues(左值)和rvalues(右值)

lvaues本质“就是指一些对象、或者是表达式。这些对象、表达式必须代表一块内存区域”。换句话说，lvaues就是代表一块内存区域的对象(object)或者是表达式(expression)。

 rvalues 被定义为“除了lvaues以外的所有对象、或者表达式”。其实，本质是“不能表示一块内存区域”。

总结：

1、 当需要保存数据的时候，需要lvalues。

2、 当需要读取数据的时候，需要rvalues。

####  lvalues和rvalues角色的相互转换

1、 根据表达式的上下文情况，lvalues在需要rvalues的地方会自动转换为rvalues。例如，

int n;

int m;

m = n+2;//这个表达式里n是rvalues

2、 rvalues永远不能转换为lvalues

**变量的内存寻址(与系统有关)**

(1)内存寻址由大到小，优先分配内存地址比较大的字节给变量，所以说变量越先定义，内存地址就越大。 如下面代码，先定义变量 a,再定义变量 b,打印出 a 的地址是 0x7fff5fbff828,b 的值是 0x7fff5fbff824。a 的地址比 b 的地址大 4 字节。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量，比如代码中变量 b的地址小于变量 a 的地址.

栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。

(2)变量地址的获取方式：& 变量名。

(3)输出地址的方式：%p。

```
#include <stdio.h>  
  
int main()   
{  
      
    int a;  
    int b;  
  
    printf("a的地址是%p\nb的地址是%p\n",&a,&b);  
    return 0;  
     
}  
```

(4)一个变量一定要先初始化才可以使用，因为 c 语言中默认一个没有初始化的变量值是一个不可知的很大值。如下面所示，a 没有初始化，打印出 a 的值是 -858993460。

```
#include <stdio.h>  
  
int main()   
{  
      
    int a;  
  
    printf("a的值是%d\n",a);  
    return 0;  
     
}  
```

**全局变量和局部变量在内存中的区别**

全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。

C语言经过编译之后将内存分为以下几个区域：

-  （1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。
-  （2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。
- （3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。
-  （4）文字常量区：存放常量字符串。程序结束后由系统释放。
-  （5）程序代码区：存放程序的二进制代码。

显然，C语言中的全局变量和局部变量在内存中是有区别的。C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；局部变量，即自动变量，保存在栈中，只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元。

栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量.

堆的内存地址生长方向与栈相反，由低到高，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，即 p2 指向的地址并不一定大于 p1 所指向的内存地址，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。

关于堆上内存空间的分配过程，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。

**变量定义：**用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。

**变量声明**：用于向程序表明变量的类型和名字。

**定义也是声明：**当定义变量时我们声明了它的类型和名字。

**extern 声明不是定义：**通过使用 extern 关键字声明变量名而不定义它。

**[注意]**

变量在使用前就要被定义或者声明。

在一个程序中，变量只能定义一次，却可以声明多次。

定义分配存储空间，而声明不会。

## 堆与栈区别

堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：
（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

（2）空间大小不同。每个进程拥有的栈大小要远远小于堆大小。理论上，进程可申请的堆大小为虚拟内存大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；

（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由`alloca()`函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。

（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。

从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。

无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。

**关于无符号的理解**

C语言中无符号字符型其实就是是长度为1个字节的整数，从本质上说也是整数类型，通常用来存放ASCII码。

整型分为无符号（unsigned）和有符号（signed）两种类型，默认整型变量是有符号的类型，char有点特别。需声明无符号类型就要在类型前加上unsigned。

无符号整型和有符号整型的区别在于无符号类型可以存放的正数范围比有符号整型中的范围大一倍，因为有符号类型将最高位储存符号，而无符号类型全都储存数字。

### const 关键字

您可以使用 **const** 前缀声明指定类型的常量，如下所示：

```
const type variable = value;
```

请注意，把常量定义为大写字母形式，是一个很好的编程习惯。

**#define** 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 **#define** 不为宏名分配内存，而 **const** 也不为常量分配内存，怎么回事呢，其实 **const** 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！

**const** 定义的是变量不是常量，只是这个变量的值不允许改变是常变量！带有类型。编译运行的时候起作用存在类型检查。

**define** 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。

## 1、两者的区别

**(1) 编译器处理方式不同**

- \#define 宏是在预处理阶段展开。
-  const 常量是编译运行阶段使用。

**(2) 类型和安全检查不同**

-  \#define 宏没有类型，不做任何类型检查，仅仅是展开。
-  const 常量有具体的类型，在编译阶段会执行类型检查。

**(3) 存储方式不同**

- \#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
- const常量会在内存中分配(可以是堆中也可以是栈中)。

**(4) const 可以节省空间，避免不必要的内存分配。 例如：**

```
#define NUM 3.14159 //常量宏
const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ......
double i = Num; //此时为Pi分配内存，以后不再分配！
double I= NUM; //编译期间进行宏替换，分配内存
double j = Num; //没有内存分配
double J = NUM; //再进行宏替换，又一次分配内存！
```

const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。

**(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。**

**(6) 宏替换只作替换，不做计算，不做表达式求解;**

宏预编译时就替换了，程序运行时，并不分配内存。

**注：**

define 注意“边缘效应”，例：**#define N 2+3**, N 的值是 5。

```
double a;
a = (float)N/(float)2;
```

在编译时我们预想 **a=2.5**，实际打印结果是 **3.5** 原因是在预处理阶段，编译器将 **a=N/2** 处理成 **a=2+3/2**，这就是 **define** 宏的边缘效应，所以我们应该写成 **#define N (2+3)**。

**小记：**在 C 语言中，单引号与双引号是有很大区别的。

在 C 语言中没有专门的字符串类型，因此双引号内的字符串会被存储到一个数组中，这个字符串代表指向这个数组起始字符的指针；

而单引号中的内容是一个 char 类型，是一个字符，这个字符对应的是 ASCII 表中的序列值。
