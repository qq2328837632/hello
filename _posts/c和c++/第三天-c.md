---
title: 第三天 c++
date: 2023-03-31 09:53:22
tags:
---

# 函数提高

## 函数默认参数

在C++中，函数的形参列表中的形参是可以有默认值的。

语法:

```
返回值类型	函数名	(参数=默认值){

}
//参数值传递会覆盖默认参数
int func(int a,int b=20,int c=30){
return a+b+c;
}
//注意事项
//1.错误，默认参数在前面则后面也必须默认值
//int func2(int a=10,int b,int c){
//return a+b+c;
//}


//2.如果函数声明有默认值，函数实现的时候不能有默认参数，相反依此
int func2(int a,intb);
int func2(int a=10,int b=10){
	return a+b;
}


int main(){
func(10,30,30);
}
```

## 函数重载

```
//函数重载的注意事项
//1、引用作为重载的条件
void func (int &a)//int &a = 10;不合法
{
	cout << "func(int &a)调用"<< endl;
}

void func (const int &a) // const int &a = 10;合法代码
{
	cout<< "func (const int &a)调用"<< end1;
}

int main(){
	int a=10;
	func(a);//输出第一个
	func(10);//输出第二个
}

```

# 类和对象

类中的属性和行为我们统一称为成员

属性称为	成员属性	成员变量

行为称为	成员函数	成员方法

## 封装意义:

类在设计时，可以把属性和行为放在不同的权限下，加以控制访问权限有三种:

1.public	公共权限

2.protected	保护权限

3.private	私有权限
示例:

```
//三种权限
//公共权限public	类内可以访问类外可以访问
//保护权限protected	类内可以访问类外不可以访问
//私有权限private	类内可以访问类外不可以访问
```

## struct和class区别

在C++中struct和class唯—的区别就在于默认的访问权限不同

区别:
struct默认权限为公共

class 默认权限为私有

```
class C1{
	int m_A;//默认是私有权限
};
struct C2{
	int m_A;//默认是公共权限
};
```

结构体声明通常不包括public或private的访问修饰符。

struct是为了兼容c而存在的,在以后尽量使用class.

## 成员属性设置为私有

优点1:将所有成员属性设置为私有，可以自己控制读写权限。

优点2:对于写权限，我们可以检测数据的有效性。

## 构造函数和析构函数

```
class Person{
public:
	//1.构造函数
	//没有返回值不用写void//函数名与类名相同
	//构造函数可以有参数，可以发生重载
	//创建对象的时候，构造函数会自动调用，而且只调用一次
	Person()
	{
	cout <<"Person构造函数的调用"<< end1;
	}
	Person(int age)
	{
	cout <<"Person有参构造函数的调用"<< end1;
	}
	//1.2拷贝构造函数
	Person( const Person &p ){
	//将传入的人身上的所有属性，拷贝到我身上
	age = p.age;
	}
	//2.析构函数进行清理的操作
	//没有返回值不写void
	//函数名和类名相同在名称前加~
	//析构函数不可以有参数的，不可以发生重载
	//对象在销毁前会自动调用析构函数，而且只会调用一次
	~Person()
	{
	cout <<"Person析构函数的调用"<< end1;
	}
};
int main(){
	Person p2=Person(10);//有参构造，也可写成Person p2(10);
	Person p3=Person(p2);//拷贝构造,也可写成Person p3(p2);
	//注意:调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明(void fuc();)
	Person p2();
	Person(10);//匿名对象﹑特点:当前行执行结束后，系统会立即回收掉匿名对象
	//不要利用拷贝构造函数初始化匿名对象瞭编译器会认为Person (p3) === Person p3;
	//Person(p3);//错误的
	//3、隐式转换法
	Person p4 = 10; //相当于写了Person p4 = Person(10) ;
}
```

构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构

## 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况：

使用一个已经创建完毕的对象来初始化一个新对象

```
Person p2=Person(10);//有参构造，也可写成Person p2(10);
Person p3=Person(p2);//拷贝构造,也可写成Person p3(p2);
```



值传递的方式给函数参数传值

```
void doWork ( Person p){

}
void test02(){
	Person p;//相当于值传递，调用了拷贝函数
	doWork(p);
}
```



以值方式返回局部对象

```
Person doWork2(){
	Person pl;
	return p1;//p1是局部对象，会拷贝一个新的person类型返回
}
void test03 (){
	Person p = doWork2();
}
```

## 构造函数调用规则

默认情况下，c++编译器至少给一个类添加3个函数

1．默认构造函数(无参，函数体为空)

2．默认析构函数(无参，函数体为空)

3．默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下:

- 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造。
- 如果用户定义拷贝构造函数，C++不会再提供其他构造函数。（拷贝构造函数也是有参数的，所以编译器不会提供无参构造函数了）

## 4.2.5深拷贝与浅拷贝

深浅拷贝是面试经典问题，也是常见的一个坑

浅拷贝:简单的赋值拷贝操作

深拷贝:在堆区重新申请空间，进行拷贝操作

```
Person (int age , int height)
{
	m_Age = age;
	m_Height =new int(height) ;//创建堆区
	cout << "Person的有参构造函数调用"<< endl;
}
/*自己实现拷贝构造函数解决浅拷贝带来的问题
若不自己实现，则有问题，浅拷贝是对成员变量的简单赋值,拷贝时会直接拷贝堆的地址,所以p2的height指针=p1的height指针,即两个height指针指向堆区的同一个地址
p2在进行拷贝初婚化时使用的是编译器提供的浅拷贝
函数test01结束后，p1和p2把同一个空间释放了两次。所以程序崩了
*/
Person(const Person &p)
{
	cout << "Person拷贝构造函数调用"<< endl;
	m_Age = p.m_Age;
	//m_Height = p.m_Height;编译器默认实现就是这行代码
	//深拷贝操作
	m_Height = new int(*p.m_Height) ;
}
~Person()
{
//析构代码，将堆区开辟数据做释放操作
	if (m_Height != NULL)
	{
		delete m_Height;
		m_Height = NULL;
	}
	cout <<"Person的析构函数调用"<< endl;
}
public:
	int m_Age;
	int *m_Height;
```

总结:如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

## 4.2.6初始化列表

作用:

C++提供了初始化列表语法，用来初始化属性

语法:构造函数()∶属性1(值1) ,属性2(值2) ... {}

```
public:
	//初始化列表初始化属性
    Person(int a, int , int c) :m_A(a), m_B(b), m_c(c)
    {
    .
    .
    }
    int m_A;
    int m_B;
    int m_C;
```

## 类对象作为类成员

C++类中的成员可以是另一个类的对象，我们称该成员为对象成员
例如∶

```
class A{}
class B
{
	A a;
}
```

B类中有对象A作为成员，A为对象成员

当其他类对象作为本类成员，构造时候先构造类对象(A)，再构造自身(B ),析构的顺序与构造相反，取木块同理。不可能直接取前面的那个，只有将后面的先取出来才能取到前面的那个。
而创建对象也是。我需要用phone对象补全person就需要先创建phone而person因为在后面，所以取的时候先取它。

## 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为:

- 静态成员变量

所有对象共享同一份数据。

在编译阶段分配内存。编译阶段就分配内存─代码还未开始前(即程序还未运行前),在全局区优先分配好内存

类内声明，类外初始化

```
class Person
{
public:
	//1所有对象都共享同一份数据
	//2编译阶段就分配内存
	//3类内声明，类外初始化操作
	static int m_A;
private:
	static int m_B;//静态成员变量也是有访问权限的，私有的类外访问不到
};
int Person::m_A = 100;//这里强调一下，是必须在类外写一下，否则报错，可以不付初值，默认初值是0,加Person是为了说明他是Person类的static 
int Person::m_B = 100;
void test(){
	//静态成员变量不属于某个对象上，所有对象都共享同一份数据
	//因此静态成员变量有两种访问方式
	//1、通过对象进行访问
	Person p;
	cout << p.m_A << endl;
	//2、通过类名进行访问
	cout <<Person::m_A << end1;
}
```



- 静态成员函数

所有对象共享同一个函数

静态成员函数只能访问静态成员变量，因为如果静态成员函数里有非静态成员变量，class会判断不出非静态成员变量是在什么地方定义的,所以无法确定是否是类成员

静态成员函数也是有访问权限的，私有的类外访问不到静态成员函数

```
//因此静态函数有两种访问方式
	//1、通过对象进行访问
	Person p;
	p.func();
	//2、通过类名进行访问
	Person::func();
```

