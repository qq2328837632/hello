---
title: c++补充
date: 2023-04-03 16:59:54
tags:
---

如果以前使用过C语言，您可能觉得前面讨论的#define语句已经足够完成这样的工作了。但const比#defien好。首先，它能够明确指定类型。其次，可以使用C++的作用域规则将定义限制在特定的函数或文件中（作用域规则描述了名称在各种模块中的可知程度，将在第9章讨论)。第三，可以将const用于更复杂的类型，如第4章将介绍的数组和结构。

提示:如果读者在学习C++之前学习过C语言，并打算使用#define来定义符号常量，请不要这样做，而应使用const。

### 默认初始化

如果定义变量时没有指定初值，则变量被默认初始化（default initialized)，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。一种例外情况是，定义在函数体内部的内置类型变量将不被初始化（uninitialized)。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。例如，以刚刚所见为例，string类规定如果没有指定初值则生成一个空串。

一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误。

建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能硝保初始化后程序安全,那么这么做不失为一种简单可靠的方法。

------

变量能且只能被定义一次,但是可以被多次声明。
声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。

### 关键概念:静态类型

C++是一种静态类型(statically typed)语言,其含义是在编译阶段检查类型。其中,检查类型的过程称为类型检查（type checking ).

我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。
程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。

### 变量命名规范

变量命名有许多约定俗成的规范，下面的这些规范能有效提高程序的可读性:标识符要能体现实际含义。
变量名一般用小写字母，如 index，不要使用Index或INDEX。用户自定义的类名一般以大写字母开头，如 Sales item。
如果标识符由多个单词组成，则单词间应有明显区分，如 student loan或
studentLoan，不要使用 studentloan。

### 指针值

指针的值（即地址）应属下列4种状态之一:

1．指向一个对象。

2．指向紧邻对象所占空间的下一个位置。

3.空指针，意味着指针没有指向任何对象。

4．无效指针，也就是上述情况之外的其他值。

试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误,这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。
尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。

------

```
int **main**() {

  **SetConsoleOutputCP**(65001);

  int i=42;

  int &r=i;

  int *p ;

  p=&i;

  *p=i;

  int &r2=*p;

  // test01();

  //test02();

  cout<<r<<endl<<&r<<endl<<*p<< endl<<p << endl<<&r2 <<endl<<r2<<endl;

  system( "pause" );

  return 0;

}
输出
42
0x61fe04
42
0x61fe04
0x61fe04
42//与上面引用类似
```

### 建议:初始化所有指针

使用未经初始化的指针是引发运行时错误的一大原因，和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这一行为将造成程序崩溃,而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。

在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值。访问该指针,相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。

因此建议初始化所有的指针,并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处,就把它初始化为nullptr或者0.这样程序就能检测并知道它没有指向任何具体的对象了。

### 赋值和指针

指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

指针和它存放的地址之间就没有这种限制了。和其他任何变量(只要不是引用)一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象

有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易,最好的办法就是记住赋值永远改变的是等号左侧的对象。当写出如下语句时

```
int *p=0;
int ival=1;
p=&ival;

//意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。相反的，如果写出如下语句，
*p=0;//ival的值被改变,指针pi并没有改变,即*(&ival)=0;
//则*pi（也就是指针pi指向的那个对象）发生改变。
```

------

利用void指针能做的事儿比较有限:拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个 void指针。不能直接操作 void指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。
概括说来，以void的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象.

### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用:

```
int i =42;
int *p;//p是一个 int型指针
int *&r =p;// r是一个对指针p的引用
r= &i;//r引用了一个指针，因此给r赋值&i就是令p指向i
*r= 0;//解引用r得到i，也就是p指向的对象，将i的值改为0
```

要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符号（此例中是&r的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。

面对一条比较复杂的指针或引用的声明语句时,从右向左阅读有助于弄清楚它的真实含义。

解引用——解释引用，说的通俗一点就是，直接去寻找指针所指的地址里面的内容，此内容可以是任何数据类型，当然也可以是指针。

```
int *p ,a=6;
p=&a;
cout<<p<<endl;
cout<<*p<<endl;//解引用,具体解释指针p所指向的内存地址里存放的内容。
```

&表示的是引用，就表示函数内的变量和主函数的变量是同一个，函数内改变它的值，主函数相应的变量也就跟着改变了；没有&符号，就表示函数内的变量是主函数的变量的一个副本，在函数内改变其值，是不会改变主函数中变量的值的。

```
int *p ,a=6;
p=&a;
int &c=a;
cout<<c<<endl;
```

脱解引用——就是用&抵消掉*对a的引用效果

```
p=&a;
cout<<&*p<<endl;
cout<<*(&*p)<<endl;
因此代码的行输出的是a的内存地址，而代码下一行输出的是a的值。
```



### const

某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。

解决的办法是，对于 const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了:
// file_l.cc定义并初始化了一个常量，该常量能被其他文件访问

extern const int bufSize = fcn();

//file l.h头文件

extern const int bufSize;//与file_1.cc中定义的bufSize是同一个

如上述程序所示，file_1.cc定义并初始化了bufsize。因为这条语句包含了初始值，所以它(显然）是一次定义。然而，因为bufsize是一个常量，必须用extern加以限定使其被其他文件使用。
file_1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现。

如果想在多个文件之间共享 const对象,必须在变量的定义之前添加extern关键字。

------



```
int i=42;
const int &r1 = i;//允许将const int&绑定到一个普通int对象上
const int &r2=42; //正确:r1是一个常量引用
const int &r3 = r1* 2; //正确:r3是一个常量引用
int &r4 = r1 * 2;//错误:r4是一个普通的非常量引用
```

要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么:

```
double dval = 3.14;
const int &ri = dval;
```

此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式:

```
const int temp = dval;//由双精度浮点数生成一个临时的整型常量
const int &ri = temp;//让ri绑定这个临时量
```

在这种情况下，ri 绑定了一个**临时量** (temporary）对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。

接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意，此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则干什么要给ri赋值呢?如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。

###  指针和 const

与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针（pointer to const)不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针:

```
const double pi =3.14;//pi是个常量,它的值不能改变
double *ptr = &pi;//错误:ptr是一个普通指针
const double *cptr = &pi;//正确:cptr可以指向一个双精度常量
*cptr =42;//错误:不能给*cptr赋值
```

指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象:

```
double dval = 3.14;//dval是一个双精度浮点数，它的值可以改变
cptr=&dval;//正确:但是不能通过cptr改变 dval的值
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

### const指针

```
int errNumb=0;
int *const curErr=&errNumb;// curErr将一直指向errNumb
const double pi=3.14159;
const double *const pip = &pi;// pip是一个指向常量对象的常量指针

```

指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针(const pointer)必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针中的那个地址）就不能再改变了。把放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即**不变的是指针本身的值**(地址)而非指向的那个值（*curErr =0;//正确:把curErr所指的对象的值重置）:所以curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值（当errNumb不为0时，）

```
//如果curErr所指的对象（也就是errNumb)的值不为0
if(*curErr) {
	errorHandler ();
	*curErr =0;//正确:把curErr所指的对象的值重置
}
```



要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。此例中，离curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它指向的对象是一个双精度浮点型常量。

###  顶层const

如前所述，指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const( top-level const）表示指针本身是个常量，而用名词底层const(low-level const）表示指针所指的对象是一个常量。
更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用,如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显:

```
int i=0;
int *const pl =&i;//不能改变p1的值，这是一个顶层const
const int ci =42;
//不能改变ci的值，这是一个顶层const
const int *p2= &ci;
//允许改变p2的值，这是一个底层const
const int &r=ci;
//  所有的引用本身都是顶层 const，因为引用一旦初始化就不能再改为其他对象的引用，这里用于声明引用的 const 都是底层 const
```

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响:

```
i= ci;//正确:铂贝ci的值，ci是一个顶层const，对此操作无影响
p2 = p3;//正确:p2和p3指向的对象类型相同,p3顶层const的部分不影响
```

执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。

另一方面，底层 const 的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行:

```
*int p= p3;
//错误:p3包含底层const的定义，而p没有
p2= p3;
//正确:p2和p3都是底层const
p2 = &i;
//正确:int*能转换成const int*
int &r =ci;
//错误:普通的int&不能绑定到int常量上
const int &r2 =i;
//正确:const int&可以绑定到一个普通int上
```

p3既是顶层const也是底层const，拷贝p3时可以不在乎它是一个顶层const，但是必须清楚它指向的对象得是一个常量。因此，不能用p3去初始化p，因为p指向的是一个普通的（非常量)整数。另一方面，p3的值可以赋给p2，是因为这两个指针都是底层const，尽管p3同时也是一个常量指针（顶层 const)，仅就这次赋值而言不会有什么影响。

### constexpr变量

在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个 const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿。
C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化:

```
constexpr int mf = 20;// 20是常量表达式
constexpr int limit = mf +1;// mf +1是常量表达式
constexpr int sz=size();//只有当size是一个constexpr函数时,才是一条正确的声明语句
```

尽管不能使用普通函数作为constexpr变量的初始值，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果,这样就能用constexpr函数去初始化constexpr变量了。

一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。

### 字面值类型

常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”(literal type）。

到目前为止接触过的数据类型中，**算术类型、引用和指针**都属于字面值类型。自定义类sales item、IO库、string 类型则不属于字面值类型，也就不能被定义成constexpr。

尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0,或者是存储于某个固定地址中的对象。

函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr 指针。允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr 引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。定义constexpr常量都要在函数体外。

必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关:

```
const int *p = nullptr;// p是一个指向整型常量的指针
constexpr int *q= nullptr; //q是一个指向整数的常量指针
```

p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。

------

```cpp
ios::sync_with_stdio(false);
cin.tie(0),cout.tie(0);
```

------

**一.sync_with_stdio**
这个函数是一个“是否兼容stdio”的开关，C++为了兼容C，保证程序在使用了`std::printf`和`std::cout`的时候不发生混乱，将输出流绑到了一起。
`cin`，`cout`之所以效率低，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低，而这段语句可以来打消iostream的输入输出缓存，可以节省许多时间，使效率与scanf与printf相差无几.

**应用**
在ACM里，经常出现数据集超大造成 cin **运行超时** /`Time Limit Exceeded`【TLE】的情况。这时候大部分人（包括原来我也是）认为这是cin的效率不及scanf的错，甚至还上升到C语言和C++语言的执行效率层面的无聊争论。其实像上文所说，这**只是C++为了兼容而采取的保守措施**。我们可以**在IO之前将stdio解除绑定**，这样做了之后要注意不要同时混用cout/cin和printf/scanf之类。

**二.tie**
`tie`是将两个stream绑定的函数，空参数的话返回当前的输出流指针。
在默认的情况下`cin`绑定的是`cout`，每次执行 << 操作符的时候都要调用flush，这样会增加IO负担。可以通过`tie(0)`（0表示NULL）来解除`cin`与`cout`的绑定，进一步加快执行效率。

------

### c++11

在 C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上= default来要求编译器生成构造函数。其中，= default 既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果= default在类的内部，则默认构造函数是内联的;如果它在类的外部，则该成员默认情况下不是内联的。

### 构造函数初始值列表

接下来我们介绍类中定义的另外两个构造函数:

```
sales_data(const std: :string &s): bookNo(s) {}
Sales_data (const std: :string &s,unsigned n, double p):
bookNo(s), units_sold(n),revenue(p*n){}
```

这两个定义中出现了新的部分，即冒号以及冒号和花括号之间的代码，其中花括号定义了(空的）函数体。我们把新出现的部分称为构造函数初始值列表(constructor initialize list)，它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的(或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。

含有三个参数的构造函数分别使用它的前两个参数初始化成员 bookNo和units_sold,revenue的初始值则通过将售出图书总数和每本书单价相乘计算得到。
只有一个string类型参数的构造函数使用这个string对象初始化bookNo，对于units sold和revenue则没有显式地初始化。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式**隐式初始化**。在此例中，这样的成员使用类内初始值初始化，因此只接受一个string参数的构造函数等价于

```
//与上面定义的那个构造函数效果相同
Sales_ data(const std: :string &s):
bookNo (s) , units_sold(0), revenue(0){}
std::string bookNo;
unsigned units_sold = 0;
double revenue = 0.0;
```

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。
