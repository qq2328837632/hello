---
title: 深入理解计算机系统
date: 2023-05-05 16:12:22
tags:
---

# 第2章 信息的表示和处理

#### 文字编码的Unicode标准

基本编码，称为Unicode的“统一字符集”，使用32位来表示字符。这好像要求文本串中每个字符要占用4个字节。不过，可以有一些替代编码，常见的字符只需要1个或2个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8表示将每个字符编码为一个字节序列，**这样标准ASCII字符还是使用和它们在ASCII 中一样的单字节编码**，这也就意味着所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的。

Java编程语言使用Unicode来表示字符串。对于C语言也有支持 Unicode的程序库。

在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，**文本数据比二进制数据具有更强的平台独立性**。

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

## c语言的移位运算

C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移--算术右移或者**逻辑右移**（不管符号均补0）都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器/机器组合都对有符号数使用**算术右移**（有符号时最高位是1补1），且许多程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。
与C相比，Java对于如何进行右移有明确的定义。表达是x>>k会将x算术右移k个位置，而x>>>k会对x做逻辑右移。

### 移动k 位，这里k 很大

对于一个由w位组成的数据类型，如果要移动k≥w位会得到什么结果呢?例如，计算下面的表达式会得到什么结果，假设数据类型int为w=32:

```
intlval =OxFEDCBA98<< 32;
intaval =OxFEDCBA98>>36;
unsigned uval =OxFEDCBA98u >>40;
```

C语言标准很小心地规避了说明在这种情况下该如何做。在许多机器上，当移动一个w位的值时，移位指令只考虑位移量的低 log2 w位，因此实际上位移量就是通过计算k mod w得到的。例如，当w=32时，上面三个移位运算分别是移动0、4和8位，得到结果:

```
lval 0xFEDCBA98
aval 0xFFEDCBA9
uval 0x00FEDCBA
```

不过这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移位值的位数。另一方面，Java 特别要求位移数量应该按照我们前面所讲的求模的方法来计算。

## 补码编码

采用补码表示的32位大端法机器（符合习惯，先输出低地址的高位）上输出打印16进制时：是看补码来转换。

原理:补码编码的定义
![image-20230507151108343](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230507151108343.png)

例如1001（-1）的补码是1111可以根据上面计算-8+7=-1

**负数的补码，是能够和其相反数相加通过溢出从而使计算机内计算结果变为0的二进制码**。这是补码设计的初衷，具体目标就是让1+（-1）=0，这利用原码是无法得到的

对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是:数值可能会改变，但是**位模式不变**。

无符号表示中的UMax竟有着和补码表示的-1相同的位模式。我们在这两个数之间也能看到这种关系
$$
:1+UMax_w=2^w
$$
原理:补码转换为无符号数
对满足TMin_x≤x≤TMax_w的x有:
$$
T2U_w(x)=\begin{cases} x+2^w,x<0\\ x,x>=0\end{cases}
$$
一个无符号数u和与之对应的有符号数U2T_w(u)之间的关系:

原理:无符号数转换为补码

对满足0≤u≤UMax _w的u有:
$$
U2T_w(u)=\begin{cases} u-2^w,u>TMax_w\\ u,x<=TMax_w\end{cases}
$$
总结一下，我们考虑无符号与补码表示之间互相转换的结果。对于在范围0≤T<TMax_w之内的值x而言，我们得到T2U_w(x)=x和U2T_w(x)=x。也就是说，在这个范围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减去2^w。例如，我们有
$$
T2U_w(-1)=-1+2^w=UMax_w
$$
----最靠近0的负数映射为最大的无符号数

## c语言里面TMin不能写成-2147483648的原因

C语言中，将TMin（32位有符号整数的最小值）写成 **-2147483647-1**，而不是简单地写成 -2147483648 或 0x80000000 。

可见如果不发生溢出，整型常量的值总是非负数。如果前面**出现符号**，则是对整型常量使用的一元运算符，而不是整型常量的一部分。

如果将TMin32写成-2147483648并且将代码在一个32位的机器上面编译，当编译器遇到**-X**形式的数值，它首先会确定**X**的数据类型和值，然后取**X**的。

由于-2147483648超过了int所能够表示的范围，编译器就会再次选择一种可以正确的表示此值的类型。然后它就会按照第一个表格（十进制）的顺序往下继续尝试类型，再假设编译器采用的标准是ISO C90，int->long->unsigned，然后就发现unsigned是第一个合适的数据类型。正如我们知道的，2147483648和-2147483648在32位数值上拥有同样的位表示，使得此常量的最终数据类型是unsigned且值为2147483648。这对于16进制的0x80000000也是相同的结果。

用一句话来解释C语言中TMin32的古怪写法的原因：虽然-2147483648 这个数值能够用int类型(4字节)来表示，但在C语言中却没法写出对应这个数值的int类型常量。

## 补码的非

原理:补码的非
对满足TMin_w≤x≤TMax_w 的x，其补码的非-^t_wx由下式给出
$$
-^t_wx=\begin{cases}TMin_w,x=TMin_w\\-x,x>TMin_w\end{cases}
$$
此处设w=4，用补码可表示的范围就是[-8,7]，对于-8，它的“补码的非”还是-8,而[-7,7]补码的非就是原数的负数，比如说-4的“补码的非”是-4取负，即：4，而3的“补码的非”是3取负，即：-3。这是“补码的非”的定义；注意：“补码的非”并不是把“一个数的补码按位取非”

TMin_w=-2^w-1

执行位级补码非的第一种方法是对每一位求反，再对结果加1。在C语言中，我们可以说，对于任意整数值x，计算表达式-x和~x+1得到的结果完全一样。

## 对TMin_w=-2^w-1的解释

如w=4的-8=1000，可以参考-2为例

[-2]原 = 1 0010    [-2]补 = 11110

如我所说，没有符号位，那么11110就是30，也就是说 -2的补码是30（%2^5）

## 补码移位

移位也是运算，需要将负数的原码变成补码移位

对无符号运算使用移位是非常简单的，部分原因是由于无符号数的右移一定是逻辑右移（不管最高位符号）。对于x大于等于0的有符号一样逻辑右移。

负数在执行算术右移之前加上一个适当的偏置量是可以导致结果正确舍入的。

补码除以2的幂(**右移之前加上一个偏量**，结果就向零舍入了).

```
int optarith(int x, int y)
{
    int t = x;
    x <<= 5;
    x -= t;
    if (y < 0)
        y += 7;//加上一个适当的偏置量111,是为了正确右移3位，若右移4位，则加15（1111）
    y >>= 3; /* Arithmetic shift */
    return x + y;
}
```

## IEEE浮点标准

IEEE浮点标准用 
$$
V=（-1）^s*M*2^E
$$
 的形式来表示一个数，符号s，尾数M，阶码E

C语言中，单精度（float）的s为1b，E为8b，M为23b，双精度（double）的s为1b，E为11b，M为52b。

阶码的值**E=e-Bias**，e是无符号数，Bias为偏置值，等于 2^(k-1)−1 (float为127，double为1023)

### 计算 IEEE 754 标准浮点数的真值

在上述内容的分析之后，再通过观察分析以下这个 IEEE 754 单精度浮点数格式表示的数，系统性了解如何计算出 IEEE 754 标准浮点数的真值：

1 100 0000 1010 0000 0000 0000 0000 0000
上数分别对应图1-1的中 S（符号码，0 正，1 负），E (阶码) ，M (尾数数值)为：

S (红色部分) ：1

```
1，表示这个浮点数是个负数；
```

E (蓝色部分) ：100 0000 1

```
100 0000 1，阶码，其真值为 ：移码 - 偏置值 => 1000 0001 - 0111 1111 = 0000 0010 = 2D；（对应下面的2^2D）
```

M (黑色部分) ：010 0000 0000 0000 0000 0000

```
010 0000 0000 0000 0000 0000 表示这个浮点数的尾数部分，其真值为：被隐含的最高位1 + 0.尾数部分 => 1 + 0.01 = 1.01B;
```

通过对 S，E，M 的分析，我们可以计算出该浮点数的真值，即：

-1.01B * 2^10B = 1.25D （-1.01B）* 2^2D = -5.0D

------

十进制数12345具有二进制[0011 0000 0011 1001]（0x3039），通过将二进制小数点左移13位，得到这个数的一个规格化表示 

```
12345=1.1000000111001_2×2^13 
```

，为了使用IEEE单精度（float）形式来编码，我们丢弃开头的1，并且在末尾增加10个0（单精度的尾数位23位，13+10=23），来构造小数字段，得到二进制[1000000111001*0000000000*]，为了得到阶码字段，将13加上偏置量127，得到140，二进制表示为[10001100]，加上符号位0，得到12345.0的二进制浮点数[0100 0110 0100 0000 1110 0100 0000 0000]（0x4640E400），比较整数12345（0x3039）和浮点数12345.0（0x4640E400）的位级表示：

（0x00003039）0000000000000000001***1000000111001***

（0x4640E400）010001100***1000000111001***0000000000

阶码的值E=e-Bias,产生指数的取值范围，对于单精度是一126～＋127，而对于双精度是一1022~+1023。

### 十进制数转为 IEEE 754 浮点数格式

同样地再用一个例子 十进制数转为 IEEE 754 浮点数的例子，加深对 十进制数 与 IEEE 754 浮点数之间的转换的理解。

 例如：将十进制数 -0.75 转为 IEEE 754 的单精度浮点数格式表示，分析过程如下：

过程A： -0.75D = -0.11B = -1.1B * 2^(-1B)
S：1

```
-0.75 为负数，故 S 符号码为 1
```

E：0111 1110

```
由 过程A 得，阶码的真值为 -0000 0001(因为是2^(-1B)，与上面例子一致) ，其移码为：-0000 0001 + 0111 1111 = 0111 1110
```

M：100 0000 0000 0000 0000 0000

```
由 过程A 得，尾数码真值为：-1.1，隐含最高位 1 ，取小数部分，得100 0000 0000 0000 0000 0000
```

最终结果为：

1 011 1111 0100 0000 0000 0000 0000 0000

## **向偶数舍人在大多数现实情况中避免了这种统计偏差**。

在50%的时间里，它将向上舍人，而在50%的时间里，它将向下舍入。
