---
title: Linux上gcc编译
date: 2023-05-14 10:41:46
tags:
---

# gcc 编译 4 步骤

GCC（GNU Compiler Collection）是由 GNU 开发的编程语言编译器。 GCC最初代表“GNU C Compiler”，当时只支持C语言。 后来又扩展能够支持更多编程语言，包括 C++、Fortran 和 Java 等。

GCC 编译工具链在编译一个C源文件时需要经过以下 4 步：

- 预处理：为把头文件的代码、宏之类的内容转换成生成的.i文件，还是C代码。
- 编译：把预处理后的.i文件通过编译成.s文件，汇编语言。
- 汇编：将汇编语言文件生成目标文件.o文件，机器码。
- 链接：将每个源文件对应的.o文件链接起来，就生成一个可执行程序文件

**（1）预处理阶段**

预处理过程中，对源代码文件中的文件包含 (include)、 预编译语句 (如宏定义define等)进行展开，生成 .i 文件。 可理解为把头文件的代码、宏之类的内容转换成更纯粹的C代码，不过生成的文件以.i为后缀。

使用GCC的参数 “-E”，可以让编译器生成 .i 文件，参数 “-o”，可以指定输出文件的名字。

具体命令如下：

```text
 # 预处理，可理解为把头文件的代码汇总成C代码，把*.c转换得到*.i文件
 gcc –E hello.c –o hello.i
```

**（2）编译阶段**（消耗时间、系统资源最多）

把预处理后的.i文件通过编译成为汇编语言，生成.s文件，即把代码从C语言转换成汇编语言，这是GCC编译器完成的工作。在这个过程，GCC会检查各个源文件的语法，即使我们调用了一个没有定义的函数，也不会报错。

GCC可以使用-S选项，让编译程序生成汇编语言的代码文件（.s后缀）。

warning时如果有行号，说明是编译阶段出错。

具体命令如下:

```powershell
 # 编译，可理解为把C代码转换为汇编代码，把*.i转换得到*.s文件
 gcc –S hello.i –o hello.s
 
 # 也可以直接以C文件作为输入进行编译，与上面的命令是等价的
 gcc –S hello.c –o hello.s
```

**（3）汇编阶段**

将汇编语言文件经过汇编，生成目标文件.o文件，每一个源文件都对应一个目标文件。即把汇编语言的代码转换成机器码，这是as汇编器完成的工作。

GCC的参数“c”表示只编译(compile)源文件但不链接，会将源程序编译成目标文件（.o后缀）。计算机只认识0或者1，不懂得C语言，也不懂得汇编语言，经过编译汇编之后，生成的目标文件包含着机器代码，这部分代码就可以直接被计算机执行。一般情况下，可以直接使用参数“c”，跳过上述的两个过程，具体命令 如下：

```powershell
 # 汇编，可理解为把汇编代码转换为机器码，把*.s转换得到*.o，即目标文件
 gcc –c hello.s –o hello.o
 
 # 也可以直接以C文件作为输入进行汇编，与上面的命令是等价的
 gcc –c hello.c –o hello.o
```

Linux下生成的 *.o目标文件、*so动态库文件以及下一小节链接阶段生成最终的可执行文件都是elf格式的， 可以使用“readelf”工具来查看它们的内容。

**（4）链接阶段**

最后将每个源文件对应的目标.o文件链接起来，就生成一个可执行程序文件，这是链接器ld完成的工作。

例如一个工程里包含了A和B两个代码文件，在链接阶段， 链接过程需要把A和B之间的函数调用关系理顺，也就是说要告诉A在哪里能够调用到fun函数， 建立映射关系，所以称之为链接。若链接过程中找不到fun函数的具体定义，则会链接报错。

虽然本示例只有一个hello.c文件，但它调用了C标准代码库的printf函数， 所以链接器会把它和printf函数链接起来，生成最终的可执行文件。

链接分为两种：

- 动态链接：GCC编译时的默认选项。动态是指在应用程序运行时才去加载外部的代码库，不同的程序可以共用代码库。 所以动态链接生成的程序比较小，占用较少的内存。
- 静态链接：链接时使用选项 “--static”，它在编译阶段就会把所有用到的库打包到自己的可执行程序中。 所以静态链接的优点是具有较好的兼容性，不依赖外部环境，但是生成的程序比较大。

执行如下命令体验静态链接与动态链接的区别：

```powershell
 # 在hello.o所在的目录执行如下命令
 # 动态链接，生成名为hello的可执行文件
 //-o是用来指定生成文件的名字
 gcc hello.o –o hello
 
 # 也可以直接使用C文件一步生成，与上面的命令等价
 gcc hello.c -o hello
 
 # 静态链接，使用--static参数，生成名为hello_static的可执行文件
 gcc hello.o –o hello_static --static
 
 # 也可以直接使用C文件一步生成，与上面的命令等价
 gcc hello.c -o hello_static --static
```

## 当头文件和源码不在一个目录下时，需要指定头文件

gcc -I ./hellodir hello.c -o hello 其中-I 参数指定头文件所在位置，位置可以在编译文件前，也可以在后面

```
-I 指定头文件所在目录位置
-c 只做预处理，编译，汇编。得到二进制文件
-g 编译时添加调试文件，用于 gdb 调试
-Wall 显示所有警告信息
-D 向程序中“动态”注册宏定义，一般可以用在调试，制作一个开关，比如ifdef,发布的时候就可以不用删除调试信息
-l 指定动态库库名
-L 指定动态库路径


```

## 动态库和静态库理论对比  

静态库在文件中静态展开，所以有多少文件就展开多少次，非常吃内存，100M 展开 100 次，就是 1G， 但是这样的好处就是静态加载的速度快 

使用动态库会将动态库加载到内存，10 个文件也只需要加载一次，然后这些文件用到库的时候临时去加载，速度慢一些，但是很省内存 

动态库和静态库各有优劣，根据实际情况合理选用即可。

- 1.动态库是否加载到内存,取决于程序是否运行
- 2.动态库每次加载的位置不固定
- 3.动、静态库共存时,编译器默认使用动态库

### 静态库制作  

静态库名字以 lib 开头，以.a 结尾 ，.a是ELF文件，可重定位目标文件。

例如：`libmylib.a` 

静态库生成指令 `ar rcs libmylib.a file1.o`

步骤一： 写好源代码

步骤二： 编译源代码生成.o 文件

步骤三： 制作静态库 ar rcs libname.a file1.o file2.o …

静态库的使用： gcc test.c lib 库名.a -o a.out

### 动态库制作-生成与位置无关代码

写在源代码里的函数，相对 main 函数偏移是一定的，链接时，回填 main 函数地址之后，其他源代码里的函数也就得到了地址。 

动态库里的函数会用一个@plt 来标识，当动态库加载到内存时，再用加载进去的地址将@plt 替换掉。

制作动态库的步骤 

1. 生成位置无关的.o 文件 `gcc -c add.c -o add.o -fPIC` 使用这个参数过后，生成的函数就和位置无关，挂上@plt 标识，等待动态绑定 
2. 使用 gcc -shared 制作动态库 `gcc -shared -o lib 库名.so add.o sub.o div.o` 
3.  编译可执行程序时指定所使用的动态库。-l:指定库名 -L:指定库路径 `gcc test.c -o a.out -l mymath -L ./lib` 
4.  运行可执行程序./a.out

#### 动态库加载错误原因及解决方式  

出错原因分析： 

连接器： 工作于链接阶段，工作时需要 -l 和 -L 

动态链接器： 工作于程序运行阶段，工作时需要提供动态库所在目录位置 

指定动态库路径并使其生效，然后再执行文件 

通过环境变量指定动态库所在位置：`export LD_LIBRARY_PATH=动态库路径`

当关闭终端，再次执行 a.out 时，又报错。 

这是因为，环境变量是进程的概念，关闭终端之后再打开，是两个进程，环境变量发生了变化。 

要想永久生效，需要修改 bash 的配置文件：`vi ~./bashrc` 

修改后要使配置文件立即生效：`. .bashrc` 或者 `source .bashrc` 或者重开终端让其自己加载 这下再执行 a.out 就不会报错

#### 动态库加载错误原因及解决方式 2  

解决方式： 

【1】 通过环境变量： `export LD_LIBRARY_PATH=动态库路径`

 ./a.out 成功！！！ （临时生效， 终端重启环境变量失效） 

【2】 永久生效： 写入 终端配置文件。 .bashrc 建议使用绝对路径。 

	1) vi ~/.bashrc
	2) 写入 export LD_LIBRARY_PATH=动态库路径 保存 
	3) ..bashrc/ source .bashrc / 重启 终端 (三种方法都可以)---> 让修改后的.bashrc 生效 
	4) ./a.out 成功！！！ 

【3】 拷贝自定义动态库 到 /lib (标准 C 库所在目录位置) 

【4】 配置文件法 

- sudo vi /etc/ld.so.conf
- 写入 动态库绝对路径 保存 
- sudo ldconfig -v 使配置文件生效。 
- ./a.out 成功！！！--- 使用 ldd a.out 查看

### 数据段合并

在链接阶段完成，节省空间，将同样工作（例如只读）的数据段合并。

## 头文件守卫：

防止头文件被重复包含 

```
#ifndef _HEAD_H_ 
#define _HEAD_H_ 
...... 
#endif
```

## gdb 调试基础指令  

使用 gdb 之前，要求对文件进行编译时增加-g 参数，加了这个参数过后生成的编译文件会大一些， 这是因为增加了 gdb 调试内容 

gdb 调试工具： 大前提：程序是你自己写的。 ---逻辑错误 

基础指令： 

​	-g：使用该参数编译可以执行文件，得到调试表。 

​	gdb ./a.out 

​	list： list 1 列出源码。根据源码指定 行号设置断点。 断点那一行不会执行

​	b： b 20 在 20 行位置设置断点。 

​	run/r: 运行程序 

​	n/next: 下一条指令（会越过函数） 

​	next/n :下一个，调用函数就跑 

​	step/s :单步，会进入调用的函数 

​	要注意的是，如果是系统函数，按 s 就出不来了，这时用 until+行号直接执行到行号处

​	s/step: 下一条指令（会进入函数） 

​	p/print：p i 查看变量的值。 

​	continue：继续执行断点后续指令。 

​	finish：结束当前函数调用。 

​	quit：退出 gdb 当前调试。 

其他指令： 

​	run：使用 run 查找段错误出现位置。 

​	set args： 设置 main 函数命令行参数 （在 start、run 之前） 

​	run 字串 1 字串 2 ...: 设置 main 函数命令行参数 

​	info b: 查看断点信息表 

​	b 20 if i = 5： 设置条件断点。 

​	ptype：查看变量类型。 

​	bt：列出当前程序正存活着的栈帧。 

​	frame： 根据栈帧编号，切换栈帧。 

​	display：设置跟踪变量 

​	undisplay：取消设置跟踪变量。 使用跟踪变量的编号。

没有符号被读取—编译时没加-g 参数 

file 后面加使用-g 编译的文件，可以不用退出，gdb 直接读取后进行调试。

## makefile 基础规则  

makefile： 管理项目。 

命名：makefile 	Makefile --- make 命令 

1 个规则： 

目标：依赖条件 

​	（一个 tab 缩进）命令 

1. 目标的时间必须晚于依赖条件的时间，否则，更新目标 
2. 依赖条件如果不存在，找寻新的规则去产生依赖条件。 

ALL：指定 makefile 的终极目标（第一行）。

2 个函数：

 

​    src = $(wildcard ./*.c): 匹配当前工作目录下的所有.c 文件。将文件名组成列表，赋值给变量 src。 src = add.c sub.c div1.c 

 

​    obj = $(patsubst %.c, %.o, $(src)): 将参数3中，包含参数1的部分，替换为参数2。 obj = add.o sub.o div1.o

 

  clean: (没有依赖)

 

​    -rm -rf $(obj) a.out “-”：作用是，删除不存在文件时，不报错。顺序执行结束。

 

  3 个自动变量：

 

​    $@: 在规则的命令中，表示规则中的目标。

 

​    $^: 在规则的命令中，表示所有依赖条件。

 

​    $<: 在规则的命令中，表示第一个依赖条件。如果将该变量应用在模式规则中，它可将依赖条件列表中的依赖依次取出，套用模式规则。

 

  模式规则：

 

​    %.o:%.c

​      gcc -c $< -o %@

 

  静态模式规则：

 

​    $(obj):%.o:%.c

​      gcc -c $< -o %@  

 

  伪目标：

 

​    .PHONY: clean ALL

 

  参数：

​    -n：模拟执行make、make clean 命令。

 

​    -f：指定文件执行 make 命令。       xxxx.mk



 makefile检测原理：

修改文件后，文件的修改时间发生变化，会出现目标文件的时间早于作为依赖材料的时间，出现这种情况的文件会重新编译。

修改sub.c后，sub.o的时间就早于sub.c ，a.out的时间也早于sub.o的时间了，于是重新编译这俩文件了。

 

## makefile两个函数和clean

src = $(wildcard *.c)

找到当前目录下所有后缀为.c的文件，赋值给src

 

obj = $(patsubset %.c,%.o, $(src))

把src变量里所有后缀为.c的文件替换成.o

rm前面的-，代表出错依然执行。比如，待删除文件集合是5个，已经手动删除了1个，就只剩下4个，然而删除命令里面还是5个的集合，就会有删除不存在文件的问题，不加这-，就会报错，告诉你有一个文件找不到。加了-就不会因为这个报错。

## makefile3个自动变量和模式规则

3个自动变量

$@ ：在规则命令中，表示规则中的目标

$< ：在规则命令中，表示规则中的第一个条件，如果将该变量用在模式规则中，它可以将依赖条件列表中的依赖依次取出，套用模式规则

$^ ：在规则命令中，表示规则中的所有条件，组成一个列表，以空格隔开，如果这个列表中有重复项，则去重

模式规则：

%.o:%.c

  gcc -c $< -o $@

## 静态模式规则

继续优化makefile，使用静态模式规则，就是指定模式规则给谁用，这里指定模式规则给obj用，以后文件多了，文件集合会有很多个，就需要指定哪个文件集合用什么规则

$(obj):%.o:%.c

gcc -c $< -o $@

再来一个扩展

当前文件夹下有ALL文件或者clean文件时，会导致makefile瘫痪，如下所示，make clean没有工作

用伪目标来解决，添加一行  .PHONY: clean ALL

还有一个扩展就是，编译时的参数，-g,-Wall这些，可以放在makefile里面

主要是注意%的匹配理解，只匹配文件名，目录位置要手动添加

如果makefile的名字变化一下，比如，叫m6

用m6执行makefile，   make -f m6

用m6执行clean      make -f m6 clean

源码 add.c,sub.c 这些在 src 目录下，.o 文件要放在 obj 目录下，头文件 head.h 在 inc 目录下。

```
src = $(wildcard ./src/*.c)	# ./src/add.c ./src/ sub.c...
obj = $(patsubst ./src/%.c, ./obj/%.o，$(src))
inc_path = ./inc
myArgs = -Wall -g
ALL:a.out
$(obj):./obj/%.o:./src/%.c
	gcc -c $< -o $@ $(myArgs) -I $(inc_path)
a.out: $(obj)
	gcc $^ -o $@ $(myArgs)
clean:
	-rm -rf $(obj) a.out
.PHONY: clean ALL
```

