---
title: 第二天 c语言
date: 2023-03-16 10:02:10
tags:
---

# C 存储类

存储类定义 C 程序中变量/函数的的存储位置、生命周期和作用域。

这些说明符放置在它们所修饰的类型之前。

下面列出 C 程序中可用的存储类：

auto

register

static

extern

## auto 存储类

**auto** 存储类是所有局部变量默认的存储类。

**auto**  普通局部栈变量，是自动存储，这种对象会自动创建和销毁 ，建议这个变量要放在堆栈上面，调用函数时分配内存，函数结束时释放内存。一般隐藏auto默认为自动存储类别。我们程序变量大多是自动变量。

## register 存储类

**register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

register 存储类定义存储在寄存器，所以变量的访问速度更快，但是它不能直接取地址，因为它不是存储在 RAM 中的。在需要频繁访问的变量上使用 register 存储类可以提高程序的运行速度。

## static 存储类

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置。

## 实例

```
#include <stdio.h>
 
/* 函数声明 */
void func1(void);
 
static int count=10;        /* 全局变量 - static 是默认的 */
 
int main()
{
  while (count--) {
      func1();
  }
  return 0;
}
 
void func1(void)
{
/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次
 * 每次调用函数 'func1' 'thingy' 值不会被重置。
 */                
  static int thingy=5;
  thingy++;
  printf(" thingy 为 %d ， count 为 %d\n", thingy, count);
}
```

实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。

## extern 存储类

**extern** 存储类用于定义在其他文件中声明的全局变量或函数。当使用 extern 关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义。

**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 **extern** 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。

extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：

**第一个文件：main.c**

## 实例

```
#include <stdio.h>
 
int count ;
extern void write_extern();
 
int main()
{
   count = 5;
   write_extern();
}
```

**第二个文件：support.c**

## 实例

```
#include <stdio.h>
 
extern int count;
 
void write_extern(void)
{
   printf("count is %d\n", count);
}
```

注意：

1、auto存储类型的变量只能在某个程序范围内使用,他采用堆栈的方式分配空间。

  在定义变量时,auto是可以省略的,如:auto  int  i;等效于int  i.

2、全局变量不允许声明为auto变量，register不适用于全局变量。

3、register是不能取址的。比如 int i；(自动为auto)int *p=&i;是对的，但register int j; int *p = &j;是错的，因为无法对寄存器的定址。

4、声明变量为register,编译器并不一定会将它处理为寄存器变量，毕竟，资源是有限的。

5、实际上现在一般的编译器都忽略auto和register申明，现在的编译器自己能够区分最好将那些变量放置在寄存器中，那些放置在堆栈中；甚至于将一些变量有时存放在堆栈，有时存放在寄存器中。

6、auto register 是用来修饰变量的,static extern 变量函数都可以。

7、Extern外部变量：如果我们希望该外部变量只能在本文件内使用，而不能被其他文件引用可以在外部变量定义时加static声明。防止别人写的模块误用。

8、全局变量会被初始化为空, 而局部变量在没有赋值前是一个垃圾值。

9、static 关键字: 修饰的局部变量是静态局部变量; 静态局部变量存值如同全局变量, 区别在于它只属于拥有它的函数; 它也会被初始化为空。

10、静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。

**Tips:**

 A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；

 B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；

 C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；

 D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带"内部存储器"功能的的函数)

 E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

#### 利用异或 **^** 来交换两个数的值，而且不引入其他变量。

```
unsigned int a=60;  //0011 1100
unsigned int b=13;  //0000 1101
a=a^b;              //a=a^b=0011 0001
b=a^b;              //b=a^b=0011 1100  相当于b1=(a^b)^b
a=a^b;              //a=a^b=0000 1101  相当于a1=(a^b)^((a^b)^b)
```

当然，这种利用位运算的交换方法只适用于整型变量，不能用于浮点型变量!

利用位与 **&** 运算，判断一个整数是否是2的整数次幂。利用这一特点，即可判断一个整数是否是2的整数次幂。

示例：

```
int func(int num)
{
    return ((num > 0) && ((num & (num - 1)) == 0));//2的n次幂大于0
}
```

返回值为 1，则输入的正整数为 2 的整数次幂，返回值为 0 则不是。

我们将 **||** 和 **&&** 定义为逻辑运算符，而 **|** 和 **&** 定义为位运算符。

**&&** 如果两个操作数都非零，则条件为真；

**||** 如果两个操作数中有任意一个非零，则条件为真。可以看出 & 和 && 在判断语句中都可以实现“和”这个功能，不过区别在于 & 两边都运算，而 && 先算 && 左侧，若左侧为 false 那么右侧就不运算了。因此从效率上来说，判断语句中推荐使用 &&（换句话就是逻辑运算就老老实实用逻辑运算符，不然它为啥叫逻辑运算符呢？）

| **&** | **返回变量的地址。** | **&a; 将给出变量的实际地址。** |
| ----- | -------------------- | ------------------------------ |
| ***** | **指向一个变量。**   | ***a; 将指向一个变量。**       |

根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数。

tips:

- 对数组元素 a[i]的引用也可以写成*(a+i)这种形式。

- 赋值语句 p=&a[0] 也可以写成下列形式: p=a。

- p 是个指针，p[i]与*(p+i)是等价的。

- ```
  int a[10];
  ```

  数组名是指向数组首个元素的指针常量，*a==a[0]，*(a+1)==a[1]，其类型应该为指向 **int** 类型的指针：

  ```
  int *;
  ```

  对数组名取地址：&a，得到的应该是整个数组的地址。这时可以认为 **a** 是整个数组的变量名，对变量名进行取地址操作：&，会得到该变量的地址；

  操作：(&a+1) 得到的是增大整个数组内存大小的地址：增大 **4\*10**。

## 内部函数

如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加 static，即

```
static 类型名 函数名 （形参表）
```

例如，函数的首行：

```
static int max(int a,int b)
```

内部函数又称静态函数。使用内部函数，可以使函数的作用域只局限于所在文件。即使在不同的文件中有同名的内部函数，也互不干扰。提高了程序的可靠性。

## 外部函数

如果在定义函数时，在函数的首部的最左端加关键字 extern，则此函数是外部函数，可供其它文件调用。

如函数首部可以为

```
extern int max (int a,int b)
```

C 语言规定，如果在定义函数时省略 extern，则默认为外部函数。

在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也要用函数原型来声明）。在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数。

## 实例

以下实例通过多个文件的函数实现输入一串字符串，然后删除指定的字符：

file1.c(文件1)

```
#include <stdio.h>

static void delete_string(char str[],char ch);
int main()
{
    extern void enter(char str[]); // 对函数的声明
    extern void print(char str[]); // 对函数的声明
    char c,str[100];
    enter(str);
    scanf("%c",&c);
    delete_string(str,c);
    print(str);
    return 0;
}

static void delete_string(char str[],char ch)//内部函数
{
    int i,j;
    for(i=j=0;str[i]!='\0';i++)
    if(str[i]!=ch)
    str[j++]=str[i];
    str[j]='\0';
}
```

file2.c(文件2)

```
#include <stdio.h>

void enter(char str[100]) // 定义外部函数 enter
{
    fgets(str, 100, stdin); // 向字符数组输入字符串
}
```

file3.c(文件3)

```
#include <stdio.h>

void print(char str[]) // 定义外部函数 print
{
    printf("%s\n",str);
}
```

输入字符串"abcdef"，给字符数组 str，在输入要删去的字符'd'。 运行结果:

```
$ gcc file1.c file2.c file3.c 
$ ./a.out
abcdef                   # 输入的字符串
d                        # 要删除的字符
abcef                    # 删除后的字符串
```

## **关于 main 函数的参数**

在有些很专业的书会看到如下代码

```
int main( int argc, char *argv[] )
```

上面的代码中 main 函数带了参数。

但是有时又会看见main函数没有参数，如下：

```
int main()
```

**那么 main 函数到底有没有参数，有没有参数会不会有什么影响？**

main 函数其实与我们写的函数没有什么区别，它也会有自己的参数。

argc 和 argv 是 main 函数的形式参数。

这两个形式参数的类型是系统规定的。如果 main 函数要带参数，就是这两个类型的参数；否则main函数就没有参数。

变量名称argc和argv是常规的名称，当然也可以换成其他名称。在传入参数后main函数收到参数后就会做自己的事。那么，实际参数是如何传递给main函数的argc和argv的呢？我们知道，C程序在编译和链接后，都生成一个exe文件，执行该exe文件时，可以直接执行；也可以在命令行下带参数执行，命令行执行的形式为：可执行文件名称 参数1 参数2 ... ... 参数n。可执行文件名称和参数、参数之间均使用空格隔开。

如果按照这种方法执行，命令行字符串将作为实际参数传递给main函数。具体为：

-  (1) 可执行文件名称和所有参数的个数之和传递给 argc；
-  (2) 可执行文件名称（包括路径名称）作为一个字符串，首地址被赋给 argv[0]，参数1也作为一个字符串，首地址被赋给 argv[1]，... ...依次类推。

## 占位符

就是先占住一个固定的位置，等着你再往里面添加内容的符号，广泛用于计算机中各类文档的编辑。

格式占位符(%)是在C/C++语言中格式输入函数，如 scanf、printf 等函数中使用。其意义就是起到格式占位的意思，表示在该位置有输入或者输出。

-  **%d, %i** 代表整数
-  **%f** 浮点
-  **%s** 字符串
-  **%c** char
-  **%p** 指针
-  **%fL** 长log
-  **%e** 科学计数
-  **%g** 小数或科学计数。
-  **%a,%A** 读入一个浮点值(仅C99有效)。
-  **%c** 读入一个字符。
-  **%d** 读入十进制整数。
-  **%i** 读入十进制，八进制，十六进制整数。
-  **%o** 读入八进制整数。
-  **%x,%X** 读入十六进制整数。
-  **%s** 读入一个字符串，遇空格、制表符或换行符结束。
-  **%f,%F,%e,%E,%g,%G** 用来输入实数，可以用小数形式或指数形式输入。
-  **%p** 读入一个指针。
-  **%u** 读入一个无符号十进制整数。
-  **%n** 至此已读入值的等价字符数。
-  **%[]** 扫描字符集合。
-  **%%** 读 % 符号

## **全局变量与局部变量在内存中的区别**：

全局变量保存在内存的全局存储区中，占用静态的存储单元；

局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。

## 初始化局部变量和全局变量

当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：

| 数据类型 | 初始化默认值 |
| :------- | :----------- |
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。

除了函数是有作用域外，其实在 **if、for、do-while** 中也是有作用域的，若在这些语句块中初始化的话，到了其外部就无法访问。

```
#include <stdio.h>

int main()
{
    for (int i = 0; i < 1; i++) {
        int a = 1;
    }
    if (1) {
        int a = 1;
    }
    int b = 1;
    while (b) {
        b--;
        int a;
    }
    switch (b) {
        case 0:
            int a = 0;
            break;
    }
    do {
        b--;
        int a = 0;
    } while (b == 0);
    int c = 0;
    if (1) {
        int c = 10;
    }
    printf("%d",a);//错误，提示未定义标识符a
    printf("%d", c);//输出“0”
}
```

## C 指向数组的指针

数组名是一个指向数组中第一个元素的常量指针。因此，在下面的声明中：

```
double balance[50];
```

**balance** 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 **p** 赋值为 **balance** 的第一个元素的地址：

```
double *p;
double balance[10];

p = balance;
```

使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。

一旦您把第一个元素的地址存储在 p 中，您就可以使用 *p、*(p+1)、*(p+2) 等来访问数组元素。
